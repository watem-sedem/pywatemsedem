<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pywatemsedem.postprocess &mdash; pywatemsedem 0.0.1a4.post1.dev1+gb8c23a5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=fbdb9ebb" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=2bb187b8"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pywatemsedem
          </a>
              <div class="version">
                0.0.1a4.post1.dev1+gb8c23a5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">pywatemsedem</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">Module Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/api.html">Data processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/calibrate.html">Calibrating WaTEM/SEDEM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/geo.html">Processing rasters and vector</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/userchoices.html">User Choices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting-started/io.html">IO</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Development guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html#package-release">Package release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../codeofconduct.html">Code of conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pywatemsedem</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pywatemsedem.postprocess</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pywatemsedem.postprocess</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">import</span> <span class="nn">shapely</span>

<span class="kn">from</span> <span class="nn">pywatemsedem.defaults</span> <span class="kn">import</span> <span class="n">SAGA_FLAGS</span>
<span class="kn">from</span> <span class="nn">pywatemsedem.geo.factory</span> <span class="kn">import</span> <span class="n">Factory</span>
<span class="kn">from</span> <span class="nn">pywatemsedem.geo.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">clean_up_tempfiles</span><span class="p">,</span>
    <span class="n">compute_statistics_rasters_per_polygon_vector</span><span class="p">,</span>
    <span class="n">create_spatial_index</span><span class="p">,</span>
    <span class="n">execute_saga</span><span class="p">,</span>
    <span class="n">get_mask_template</span><span class="p">,</span>
    <span class="n">get_rstparams</span><span class="p">,</span>
    <span class="n">load_raster</span><span class="p">,</span>
    <span class="n">raster_array_to_pandas_dataframe</span><span class="p">,</span>
    <span class="n">raster_dataframe_to_arr</span><span class="p">,</span>
    <span class="n">rasterprofile_to_rstparams</span><span class="p">,</span>
    <span class="n">set_no_data_rst</span><span class="p">,</span>
    <span class="n">write_arr_as_rst</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pywatemsedem.grasstrips</span> <span class="kn">import</span> <span class="n">estimate_ste</span>
<span class="kn">from</span> <span class="nn">pywatemsedem.io.folders</span> <span class="kn">import</span> <span class="n">CatchmentFolder</span><span class="p">,</span> <span class="n">ScenarioFolders</span>
<span class="kn">from</span> <span class="nn">pywatemsedem.io.modeloutput</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_efficiency_buffers</span><span class="p">,</span>
    <span class="n">create_deposition_raster</span><span class="p">,</span>
    <span class="n">create_erosion_raster</span><span class="p">,</span>
    <span class="n">define_subcatchments_saga</span><span class="p">,</span>
    <span class="n">identify_individual_priority_catchments</span><span class="p">,</span>
    <span class="n">load_total_sediment_file</span><span class="p">,</span>
    <span class="n">make_routing_vct_saga</span><span class="p">,</span>
    <span class="n">open_txt_routing_file</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.plots</span> <span class="kn">import</span> <span class="n">plot_cumulative_sedimentload</span>
<span class="kn">from</span> <span class="nn">.scenario</span> <span class="kn">import</span> <span class="n">CNWSException</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">zip_folder</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="valid_ditches_sewers">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_ditches_sewers">[docs]</a>
<span class="k">def</span> <span class="nf">valid_ditches_sewers</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to check if DTM raster is defined.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrapper&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_ditches_in&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_sedimentload_sewers_and_ditches</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="valid_erosion_deposition">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_erosion_deposition">[docs]</a>
<span class="k">def</span> <span class="nf">valid_erosion_deposition</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to check if DTM raster is defined.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrapper&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_erosion&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_erosion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_erosion_raster</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_deposition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_deposition_raster</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="valid_routing_vector">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_routing_vector">[docs]</a>
<span class="k">def</span> <span class="nf">valid_routing_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if routing vector is defined&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No routing vector created, please first run &#39;make_routing_vct&#39;.&quot;</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="valid_routing_sediout_vector">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_routing_sediout_vector">[docs]</a>
<span class="k">def</span> <span class="nf">valid_routing_sediout_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if routing vector is defined&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;No routing vector (with sediout) created, please rirst run &quot;</span>
            <span class="s2">&quot;&#39;couple_sediout_routing.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="valid_endpoints">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_endpoints">[docs]</a>
<span class="k">def</span> <span class="nf">valid_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if endpoints are in available&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_endpoints&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No endpoints in catchments.&quot;</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="valid_rivers">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_rivers">[docs]</a>
<span class="k">def</span> <span class="nf">valid_rivers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if rivers are available&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_riverrouting&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No rivers in catchments.&quot;</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="valid_sinks">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.valid_sinks">[docs]</a>
<span class="k">def</span> <span class="nf">valid_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if any sinks present in catchment&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_endpoints&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_riverrouting&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No sinks (rivers and endpoints) in catchments.&quot;</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>



<div class="viewcode-block" id="PostProcess">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess">[docs]</a>
<span class="k">class</span> <span class="nc">PostProcess</span><span class="p">(</span><span class="n">Factory</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialisation of the postprocess class.</span>

<span class="sd">    This class is used to process output data layers of data processing</span>
<span class="sd">    pywatemsedem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name: str</span>
<span class="sd">        Name of catchment to which results of scenario run are written too</span>
<span class="sd">    scenario_nr: int</span>
<span class="sd">        scenario number</span>
<span class="sd">    year: int</span>
<span class="sd">        simulation year</span>
<span class="sd">    resolution: int</span>
<span class="sd">        model resolution</span>
<span class="sd">    epsg: int, default 31370</span>
<span class="sd">        epsg-code</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pywatemsedem.postprocess import PostProcess()</span>
<span class="sd">    &gt;&gt;&gt; pp = PostProcess(r&quot;molenbeek&quot;, 1, 2019, 20, 31370) # note that the folder</span>
<span class="sd">    &gt;&gt;&gt; #modelbeek/scenario_1 and molenbeek/scenario_1/2019 must exist</span>
<span class="sd">    &gt;&gt;&gt; pp.make_routing_vct() #make a vector file of the text routig file.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">scenario_label</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">epsg</span><span class="p">):</span>

        <span class="c1"># general</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subcatchments_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;scenario_</span><span class="si">{</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span> <span class="o">=</span> <span class="n">scenario_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year</span> <span class="o">=</span> <span class="n">year</span>

        <span class="c1"># test if fmap_results is found</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfolder</span> <span class="o">=</span> <span class="n">CatchmentFolder</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span> <span class="o">=</span> <span class="n">ScenarioFolders</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfolder</span><span class="p">,</span> <span class="n">scenario_label</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfolder</span><span class="o">.</span><span class="n">check_home_folder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfolder</span><span class="o">.</span><span class="n">check_catchment_folder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">check_scenario</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">check_years</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">check_cnwsinput</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">check_cnwsoutput</span><span class="p">(</span><span class="n">error_if_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">check_postprocessing</span><span class="p">(</span><span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get raster properties based on DTM .tif file in Data_Bekken</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rstparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span> <span class="o">=</span> <span class="n">get_rstparams</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">cnwsinput_folder</span><span class="p">,</span>
            <span class="n">catchmentname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="p">,</span>
            <span class="n">epsg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># intialize functionalities factory</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">resolution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span> <span class="o">-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;minmax&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">cnwsinput_folder</span> <span class="o">/</span> <span class="s2">&quot;mask.rst&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr_bindomain</span> <span class="o">=</span> <span class="n">get_mask_template</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">cnwsinput_folder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span>
        <span class="p">)</span>

        <span class="c1"># regenerate user choices based on generated files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_model_options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_output_options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># automatically assign</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_filenames</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">scenario_folder</span><span class="p">)</span>

        <span class="c1"># initialize path postprocessing files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_routing&quot;</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_missing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_nonriver</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_sediexport</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_sewerin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rst_endpoints_sewer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rst_endpoints_ditch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rst_sinks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_sediout</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rst_subcatchment_sinks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_subcatchment_sinks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_subcatchment_priority</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_subcatchment_priority</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Getter Sinks attribute.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sinks</span>

    <span class="nd">@sinks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raster</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raster: pathlib.Path | str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sinks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raster_factory</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">flag_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="PostProcess.assign_filenames">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.assign_filenames">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_filenames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmap_results</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use filestructure defined in the package to appoint names of files</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmap_results: str or pathlib.Path</span>
<span class="sd">            Folder path (scenario_XX)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">df_datastructure_files</span> <span class="o">=</span> <span class="n">read_filestructure</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df_datastructure_files</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">get_tuple_datastructure</span><span class="p">(</span><span class="n">df_datastructure_files</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="n">argument_inputs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
                <span class="s2">&quot;catchment_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="p">,</span>
                <span class="s2">&quot;scenario&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_filename</span><span class="p">(</span>
                <span class="n">fmap_results</span><span class="p">,</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">argument_inputs</span>
            <span class="p">)</span>
            <span class="n">tag_variable</span> <span class="o">=</span> <span class="n">df_datastructure_files</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;tag_variable&quot;</span><span class="p">]</span>
            <span class="n">prefix_variable</span> <span class="o">=</span> <span class="n">df_datastructure_files</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;prefix_variable&quot;</span><span class="p">]</span>
            <span class="n">files</span><span class="p">[</span><span class="n">prefix_variable</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">tag_variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="n">files</span></div>


<div class="viewcode-block" id="PostProcess.process_and_check_filename">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.process_and_check_filename">[docs]</a>
    <span class="k">def</span> <span class="nf">process_and_check_filename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fmap_results</span><span class="p">,</span>
        <span class="n">subfolder</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">extension</span><span class="p">,</span>
        <span class="n">arguments</span><span class="p">,</span>
        <span class="n">mandatory</span><span class="p">,</span>
        <span class="n">condition</span><span class="p">,</span>
        <span class="n">arguments_input</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build full filename and set conditions coupled to the presence of a</span>
<span class="sd">        file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmap_results: str or pathlib.Path</span>
<span class="sd">            Folder path (scenario_XX)</span>
<span class="sd">        subfolder: str or pathlib.Path</span>
<span class="sd">            Folder path in which a specific file &#39;filename&#39; resides</span>
<span class="sd">        filename: str</span>
<span class="sd">            File path (without full path, without extension, with string</span>
<span class="sd">            formatting %)</span>
<span class="sd">        extension: str</span>
<span class="sd">            Extension of the file (e.g. .tif, .shp, ..)</span>
<span class="sd">        arguments:</span>
<span class="sd">            Argument for the string formatting</span>
<span class="sd">        mandatory: int</span>
<span class="sd">            Indicate whether file is a mandatory file (0/1)</span>
<span class="sd">        condition</span>
<span class="sd">            Condition coupled when file is present (e.g. `Include buffers`,</span>
<span class="sd">            `Include sewers`, ..)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        full_filename: pathlib.Path</span>
<span class="sd">            File path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_filename</span> <span class="o">=</span> <span class="n">process_filename</span><span class="p">(</span>
            <span class="n">fmap_results</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">extension</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">arguments_input</span>
        <span class="p">)</span>
        <span class="n">exists</span> <span class="o">=</span> <span class="n">check_if_file_exists</span><span class="p">(</span><span class="n">full_filename</span><span class="p">,</span> <span class="n">mandatory</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_condition_files</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">exists</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">mandatory</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">open</span><span class="p">(</span><span class="n">full_filename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Mandatory file &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; not found&quot;</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">open</span><span class="p">(</span><span class="n">full_filename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Optional file &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; not found, ignoring&quot;</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">full_filename</span></div>


<div class="viewcode-block" id="PostProcess.check_condition_files">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.check_condition_files">[docs]</a>
    <span class="k">def</span> <span class="nf">check_condition_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">exists</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set conditions coupled to the presence of a file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition: str</span>
<span class="sd">            Specific condition coupled to the presence of a file</span>
<span class="sd">        exists: bool</span>
<span class="sd">            File exist (True/False)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The condition defines which pywatemsedem option</span>
<span class="sd">        (see :func:pywatemsedem.CNWS.UserChoices) should be considered as</span>
<span class="sd">        True/False given that a file (exists) is present in the pywatemsedem</span>
<span class="sd">        filesystem. For example: the presence of the buffers.rst raster in the</span>
<span class="sd">        modeloutput indicates that the Include buffers option was set to True in</span>
<span class="sd">        the pywatemsedem data processing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lst_output_options</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Write aspect&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write LS factor&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write slope&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write upstream area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write routing table&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write RUSLE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write sediment export&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Write water erosion&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Output per river segment&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">lst_ecm_options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Include buffers&quot;</span><span class="p">,</span> <span class="s2">&quot;UseGras&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">condition</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;Include sewers&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_model_options</span><span class="p">[</span><span class="s2">&quot;Include sewers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_model_options</span><span class="p">[</span><span class="s2">&quot;Include sewers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">elif</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">lst_ecm_options</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">elif</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">lst_output_options</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_output_options</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dict_output_options</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Condition &#39;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&#39; not know, check implementation in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;datamodel&#39;&quot;</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.zip_folder">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.zip_folder">[docs]</a>
    <span class="k">def</span> <span class="nf">zip_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Zip output folder of scenario_x&quot;&quot;&quot;</span>
        <span class="n">zip_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">scenario_folder</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.compute_statistics_rasters_per_polygon_vector">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.compute_statistics_rasters_per_polygon_vector">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_statistics_rasters_per_polygon_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vct</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute statistics for raster for an input polygon vector</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vct: pathlib.Path</span>
<span class="sd">            Polygon vector file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geopandas.GeoDataFrame</span>
<span class="sd">            Geopandas dataframe of vct with statistics per polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_operators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;SUM&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vct</span><span class="o">.</span><span class="n">stem</span><span class="si">}</span><span class="s2">_statistics.shp&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_erosion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_erosion_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_deposition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_deposition_raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">lst_rasters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_erosion&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_deposition&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediexport&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sewers_in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_ditches_in&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
        <span class="p">]</span>
        <span class="n">lst_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Erosion (kg)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Deposition (kg)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;River (kg)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Sewers (kg)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Ditches (kg)&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">compute_statistics_rasters_per_polygon_vector</span><span class="p">(</span>
            <span class="n">lst_rasters</span><span class="p">,</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">vct</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="n">vct_out</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span>
            <span class="n">lst_names</span><span class="p">,</span>
            <span class="n">dict_operators</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.identify_subcatchments_to_buffers">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_subcatchments_to_buffers">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_subcatchments_to_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define the seperate subcatchments to the buffer outlets</span>

<span class="sd">        See :func:`pywatemsedem.postprocess.identify_subcatchments_to_buffers`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Defining catchments to buffers...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span><span class="p">[</span><span class="s2">&quot;Include buffers&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_nonriver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_river_routing</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_nonriver</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_river_routing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_nonriver</span>
            <span class="n">identify_subcatchments_to_buffers</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_buffers&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_buffers&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_nonriver</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;No buffers simulated in model. Can not identify &quot;</span>
                <span class="s2">&quot;subcatchments to buffer.&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.identify_priority_areas">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_priority_areas">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_priority_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">flag_merge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify priority areas</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nmax: str</span>
<span class="sd">            Maximum number of priority areas.</span>
<span class="sd">        flag_merge: bool</span>
<span class="sd">            Merge the separate priority areas to one shapefile.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Algorithm to identify priority areas:</span>

<span class="sd">        1. Load sediout raster as an array</span>
<span class="sd">        2. Identify pixel with highest sediout value i.</span>
<span class="sd">        3. Identify subcatchment j coupled to this highest sediout value i.</span>
<span class="sd">        4. Set all sediment values within subcathcment j to no_value.</span>
<span class="sd">        5. Repeat 2 until 4, for a number of iterations (nmax).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate temporary folder to write maps</span>
        <span class="n">tempfolder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;priority_areas&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tempfolder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">tempfolder</span><span class="p">)</span>

        <span class="c1"># load SediOut_kg file</span>
        <span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">])</span>

        <span class="c1"># delineate individual catchments based on highest values in sediout</span>
        <span class="n">gdf_subcatchmpriority</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_individual_priority_catchments</span><span class="p">(</span>
            <span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="p">,</span> <span class="n">nmax</span>
        <span class="p">)</span>
        <span class="c1"># merge overlapping catchments into joint catchments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_overlapping_catchments</span><span class="p">(</span><span class="n">gdf_subcatchmpriority</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="n">flag_merge</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set modeloutput routing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        routing_file: pathlib.Path</span>
<span class="sd">            See :ref:`here &lt;watemsedem:routingtxt&gt;`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame:</span>
<span class="sd">            with columns:</span>

<span class="sd">            - *row* (float)</span>
<span class="sd">            - *col* (float)</span>
<span class="sd">            - *targetcol1* (float): target 1 col</span>
<span class="sd">            - *targetrow1* (float): target 1 row</span>
<span class="sd">            - *targetcol2* (float): target 2 col</span>
<span class="sd">            - *targetrow2* (float): target 2 row</span>
<span class="sd">            - *part1*: share (in [0,1])</span>
<span class="sd">            - *part2*: share (in [0,1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_routing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">routing_non_river</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Getter routing (no river routing) long format</span>

<span class="sd">        River routing is removed from the routing table</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame:</span>
<span class="sd">            with columns:</span>

<span class="sd">            - *row* (float)</span>
<span class="sd">            - *col* (float)</span>
<span class="sd">            - *targetcol* (float): target col</span>
<span class="sd">            - *targetrow* (float): target row</span>
<span class="sd">            - *part*: share (in [0,1])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_routing_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="p">,</span> <span class="n">include_fields</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">]]</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="p">[</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">routing</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
        <span class="p">]</span>

<div class="viewcode-block" id="PostProcess.identify_priority_catchments_based_on_highest_loads">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_priority_catchments_based_on_highest_loads">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_priority_catchments_based_on_highest_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify the priority catchments.</span>

<span class="sd">        Identify the pixels with the highest loads in the sediout raster,</span>
<span class="sd">        sort them from high too low, and delineate the subcatchment for these</span>
<span class="sd">        pixels up until nmax catchments. See</span>
<span class="sd">        :func:`pywatemsedem.postprocess.identify_individual_priority_catchments`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nmax: int</span>
<span class="sd">            Maximum number of catchment to identify</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">])</span>
        <span class="n">temp_routing_wide</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routing_non_river_wide</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">temp_routing_wide</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">identify_individual_priority_catchments</span><span class="p">(</span>
            <span class="n">arr_sediout</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">,</span>
            <span class="n">temp_routing_wide</span><span class="p">,</span>
            <span class="n">nmax</span><span class="p">,</span>
            <span class="n">resmap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
            <span class="n">epsg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">clean_up_tempfiles</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">temp_routing_wide</span><span class="p">),</span> <span class="s2">&quot;txt&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.merge_overlapping_catchments">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.merge_overlapping_catchments">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_overlapping_catchments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf_subcatchmpriority</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge overlapping catchments and reassign priorities for</span>
<span class="sd">        overlapping catchments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf_subcatchmpriority: geopandas.GeoDataFrame</span>
<span class="sd">            Catchment shapes with number of catchment.</span>
<span class="sd">        merge: bool, default True</span>
<span class="sd">            Merge the separate priority areas to one shapefile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">merge</span><span class="p">:</span>

            <span class="c1"># fix formatting</span>
            <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">gdf_subcatchmpriority</span> <span class="o">=</span> <span class="n">gdf_subcatchmpriority</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="s2">&quot;VALUE&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Merge overlapping shapes together and assign how many times it</span>
            <span class="c1"># was identified</span>
            <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># make a new dataframe with overlapping shapes together</span>
            <span class="n">l_priorities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">l_polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">l_sediout_low</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">l_sediout_high</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">while</span> <span class="n">cond</span><span class="p">:</span>

                <span class="c1"># identify intersects</span>
                <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gdf_subcatchmpriority</span><span class="p">))</span>
                <span class="p">]</span>

                <span class="c1"># get union of these intersecting polygons and their</span>
                <span class="c1"># priority id</span>
                <span class="n">gdf_polygons</span> <span class="o">=</span> <span class="n">gdf_subcatchmpriority</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">],</span> <span class="s2">&quot;geometry&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">gdf_sediout_intersect</span> <span class="o">=</span> <span class="n">gdf_subcatchmpriority</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">],</span> <span class="s2">&quot;sediout&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="n">l_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">cascaded_union</span><span class="p">(</span><span class="n">gdf_polygons</span><span class="p">))</span>
                <span class="n">l_sediout_low</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">gdf_sediout_intersect</span><span class="p">))</span>
                <span class="n">l_sediout_high</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gdf_sediout_intersect</span><span class="p">))</span>
                <span class="n">l_priorities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># remove records from dataframe so no duplicates are analyzed</span>
                <span class="n">gdf_subcatchmpriority</span> <span class="o">=</span> <span class="n">gdf_subcatchmpriority</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="ow">not</span> <span class="n">gdf_subcatchmpriority</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">]</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf_subcatchmpriority</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># generate new dataframe with</span>
            <span class="n">gpd_priorities</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l_priorities</span><span class="p">,</span> <span class="n">l_sediout_low</span><span class="p">,</span> <span class="n">l_sediout_high</span><span class="p">])),</span>
                <span class="n">geometry</span><span class="o">=</span><span class="n">l_polygons</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;priority&quot;</span><span class="p">,</span> <span class="s2">&quot;sediout_min&quot;</span><span class="p">,</span> <span class="s2">&quot;sediout_max&quot;</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l_priorities</span><span class="p">)),</span>
            <span class="p">)</span>

            <span class="n">gpd_priorities</span> <span class="o">=</span> <span class="n">gpd_priorities</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;epsg&quot;</span><span class="p">],</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;priority_catchments_merged.shp&quot;</span>
            <span class="n">gpd_priorities</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.convert_rst_sediexport_to_vct">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.convert_rst_sediexport_to_vct">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_rst_sediexport_to_vct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the sediexport raster to a vector file.&quot;&quot;&quot;</span>
        <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediexport&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;.shp&quot;</span>
        <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="n">vct_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_sediexport</span> <span class="o">=</span> <span class="n">convert_rst_sinks_to_vct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediexport&quot;</span><span class="p">],</span> <span class="n">vct_out</span><span class="p">,</span> <span class="s2">&quot;river&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;epsg&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.convert_rst_sewerin_to_vct">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.convert_rst_sewerin_to_vct">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_rst_sewerin_to_vct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the sewerin raster to a vector file.&quot;&quot;&quot;</span>
        <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sewerin&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;.shp&quot;</span>
        <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="n">vct_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_sewerin</span> <span class="o">=</span> <span class="n">convert_rst_sinks_to_vct</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sewerin&quot;</span><span class="p">],</span> <span class="n">vct_out</span><span class="p">,</span> <span class="s2">&quot;sewer&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;epsg&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.merge_vct_sinks">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.merge_vct_sinks">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_vct_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge vct_sewerin and vct_sediexport to one sinks shapefile.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_sewerin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_sediexport</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf_sewerin</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_sewerin</span><span class="p">)</span>
            <span class="n">gdf_sewerin</span> <span class="o">=</span> <span class="n">gdf_sewerin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_sediexport&quot;</span><span class="p">]),</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">gdf_sewerin</span> <span class="o">=</span> <span class="n">gdf_sewerin</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;sediment&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">gdf_sewerin</span><span class="p">[</span><span class="s2">&quot;cumsum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_sewerin</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="n">gdf_sewerin</span><span class="p">[</span><span class="s2">&quot;cumperc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">gdf_sewerin</span><span class="p">[</span><span class="s2">&quot;cumsum&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">gdf_sewerin</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">gdf_sewerin</span> <span class="o">=</span> <span class="n">gdf_sewerin</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">vct_out</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;sewer_and_riversinks_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">_s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.shp&quot;</span>
            <span class="p">)</span>
            <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="n">vct_out</span>
            <span class="n">gdf_sewerin</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.compute_source_sinks">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.compute_source_sinks">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_source_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source-sink algorithm to identify sources of erosion</span>
<span class="sd">        (parcels or subcatchments) that lead to sediment sinks in the river</span>
<span class="sd">        (or sewer).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentage: int</span>
<span class="sd">            X % highest load that the user wants to analyse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">percentage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_sinks</span><span class="p">(</span><span class="n">percentage</span><span class="p">)</span>
        <span class="n">dict_rst_subcatchmsinks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dict_vct_subcatchmsinks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.txt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routing_non_river</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">dict_rst_subcatchmsinks</span><span class="p">[</span><span class="n">percentage</span><span class="p">],</span>
            <span class="n">dict_vct_subcatchmsinks</span><span class="p">[</span><span class="n">percentage</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">define_subcatchments_saga</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rst_sinks</span><span class="p">,</span>
            <span class="n">temp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;sourcesink_perc_</span><span class="si">{</span><span class="n">percentage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># assign cumulative percentage, percentage and class</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">dict_vct_subcatchmsinks</span><span class="p">[</span><span class="n">percentage</span><span class="p">])</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;VALUE&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
        <span class="p">)</span>
        <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;epsg&quot;</span><span class="p">],</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># check lijn hieronder</span>
        <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">dict_vct_subcatchmsinks</span><span class="p">[</span><span class="n">percentage</span><span class="p">])</span>
        <span class="n">clean_up_tempfiles</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="s2">&quot;txt&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.identify_sinks">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_sinks">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_sinks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify X % highest sinks of sediment.</span>

<span class="sd">        Analyse cumulative sediment load by sorting SediExport</span>
<span class="sd">        from high to low, and identify sediment sinks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentage: int</span>
<span class="sd">            x percentage highest load that the user wants to analyse</span>
<span class="sd">        rst_sinks: str</span>
<span class="sd">            filename of raster that contains sink point (values in raster</span>
<span class="sd">            should be between 0 and 100 %)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sediexport: pandas.DataFrame</span>
<span class="sd">            Data Frame format of SediExport raster (format: see</span>
<span class="sd">            :func:`pywatemsedem.utils.raster_array_to_pandas_dataframe`)</span>
<span class="sd">        percentage: int</span>
<span class="sd">            Updated x percentage highest load that the user want to analyse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr_sediexport</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediexport&quot;</span><span class="p">])</span>
        <span class="n">arr_sediexport</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">arr_sediexport</span> <span class="o">==</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr_sediexport</span>
        <span class="p">)</span>

        <span class="c1"># if self.dict_model_options[&quot;Include sewers&quot;]:</span>
        <span class="c1">#    arr_endpoints, _ = load_raster(self.files[&quot;rst_endpoints&quot;])</span>
        <span class="c1">#    arr_endpoints = np.where(arr_endpoints == -9999, 0, arr_endpoints)</span>
        <span class="c1">#    arr_sediexport += arr_endpoints</span>

        <span class="n">df_sediexport</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span>
            <span class="n">arr_sediexport</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rp</span><span class="o">.</span><span class="n">rasterio_profile</span>
        <span class="p">)</span>
        <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span>

        <span class="c1"># sort and select points</span>
        <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">percentage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analyse_cumulative_sediexport</span><span class="p">(</span>
            <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">percentage</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">arr_sediexport</span> <span class="o">=</span> <span class="n">raster_dataframe_to_arr</span><span class="p">(</span>
            <span class="n">df_sediexport</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rp</span><span class="o">.</span><span class="n">rasterio_profile</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rst_sinks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;sinks.tif&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sinks</span> <span class="o">=</span> <span class="n">arr_sediexport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sinks</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rst_sinks</span><span class="p">,</span> <span class="s2">&quot;tiff&quot;</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">9999</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">percentage</span></div>


<div class="viewcode-block" id="PostProcess.analyse_cumulative_sediexport">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.analyse_cumulative_sediexport">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse_cumulative_sediexport</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">df_sediexport</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">percentage</span><span class="p">,</span> <span class="n">delta_perc</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyse cumulative sediment load by sorting SediExport values</span>
<span class="sd">        from high to low</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_sediexport: pandas.DataFrame</span>
<span class="sd">            Data Frame format of SediExport raster (format: see</span>
<span class="sd">            :func:`pywatemsedem.utils.raster_array_to_pandas_dataframe`)</span>
<span class="sd">        profile: rasterio.profiles</span>
<span class="sd">            see :func:`rasterio.open`</span>
<span class="sd">        percentage: int</span>
<span class="sd">            x percentage highest load that the user wants to analyse</span>
<span class="sd">        delta_perc: int</span>
<span class="sd">            delta used to iterate percentage</span>
<span class="sd">        plot: bool, default False</span>
<span class="sd">            True if you want a cumulative SediExport plot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_sediexport: pandas.DataFrame</span>
<span class="sd">            Data Frame format of SediExport raster (format: see</span>
<span class="sd">            :func:`pywatemsedem.utils.raster_array_to_pandas_dataframe`) added</span>
<span class="sd">            with:</span>

<span class="sd">            - *cum_perc* (float): cumulative highest load</span>
<span class="sd">            - *perc* (float): percentage highest load</span>
<span class="sd">            - *class* (int): class as defined by `delta_perc`</span>

<span class="sd">        percentage: str</span>
<span class="sd">            updated percentage</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sort according to values of sediment load into river</span>
        <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;sediexport&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
        <span class="n">df_sediexport</span> <span class="o">=</span> <span class="n">df_sediexport</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;sediexport&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># calculate cumulative sum, in percentage</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;sediexport&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span>
        <span class="p">)</span>
        <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cum_sum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;sediexport&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">100</span>
            <span class="o">*</span> <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cum_sum&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;sediexport&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plot_cumulative_sedimentload</span><span class="p">(</span>
                <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">],</span>
                <span class="n">percentage</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;cumulative_sediexport.png&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># hotfix on percentage: if the first percentage is higher than the</span>
        <span class="c1"># user-predefined percentage, adjust it (small catchments)!</span>
        <span class="n">cum_sum_sinks0</span> <span class="o">=</span> <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cum_sum_sinks0</span> <span class="o">&gt;</span> <span class="n">percentage</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Sinks receiving most sediment has a cumulative relative &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;sediment load higher than </span><span class="si">{</span><span class="n">percentage</span><span class="si">}</span><span class="s2">%, &quot;</span>
            <span class="p">)</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;changing percentage </span><span class="si">{</span><span class="n">percentage</span><span class="si">}</span><span class="s2">% &quot;</span> <span class="sa">f</span><span class="s2">&quot;to </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">cum_sum_sinks0</span><span class="p">)</span><span class="si">}</span><span class="s2">%&quot;</span>
            <span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">cum_sum_sinks0</span><span class="p">)</span>

        <span class="c1"># prepare ids for subcatchment delineation</span>
        <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>
        <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>

        <span class="c1"># assign unique id&#39;s - in order of importance - to records</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">percentage</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="o">~</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># calculate percentage</span>
        <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;perc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_sediexport</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># chekc if begin percentage is below delta_perc</span>
        <span class="n">bperc</span> <span class="o">=</span> <span class="n">delta_perc</span>
        <span class="n">eperc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">percentage</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bperc</span><span class="p">:</span>
            <span class="n">bperc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bperc</span><span class="p">,</span> <span class="n">eperc</span><span class="p">,</span> <span class="n">delta_perc</span><span class="p">):</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">delta_perc</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">df_sediexport</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="n">df_sediexport</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">df_sediexport</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;perc&quot;</span><span class="p">,</span> <span class="s2">&quot;cum_perc&quot;</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="s2">&quot;sediexport&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">percentage</span><span class="p">),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.identify_export_parcel">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_export_parcel">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_export_parcel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify total sediment leaving a parcel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_prckrt: geopandas.GeoDataFrame</span>
<span class="sd">            See</span>
<span class="sd">            :func:`pywatemsedem.postprocess.PostProcess.aggregate_sedout_parcel`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># couple sediment out to routing file</span>
        <span class="n">valid_routing_sediout_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">gdf_routing_sediout</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_sediout</span><span class="p">)</span>
        <span class="n">gdf_routing_out_of_parcel</span> <span class="o">=</span> <span class="n">select_routing_out_of_parcel</span><span class="p">(</span><span class="n">gdf_routing_sediout</span><span class="p">)</span>
        <span class="n">out_shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;routing_out_of_parcel.shp&quot;</span>
        <span class="n">gdf_routing_out_of_parcel</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">out_shp</span><span class="p">)</span>
        <span class="n">create_spatial_index</span><span class="p">(</span><span class="n">out_shp</span><span class="p">)</span>
        <span class="n">df_prckrt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_sedout_parcel</span><span class="p">(</span><span class="n">gdf_routing_out_of_parcel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_prckrt</span></div>


<div class="viewcode-block" id="PostProcess.aggregate_sedout_parcel">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.aggregate_sedout_parcel">[docs]</a>
    <span class="k">def</span> <span class="nf">aggregate_sedout_parcel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gdf_routing</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aggregate sediment leaving on the scale of single parcels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gdf_routing: pandas.DataFrame</span>
<span class="sd">            dataframe format of routing file, indicating which target cells</span>
<span class="sd">            flor in which source cells.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_prckrt: pandas.DataFrame</span>
<span class="sd">            prckrt added with sediout for every pixel defined per parcel</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load perceelskaart in dataframe format</span>
        <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">])</span>
        <span class="n">df_prckrt</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">]:</span>
            <span class="n">df_prckrt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_prckrt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># aggregate sediout of routing to parcel scale</span>
        <span class="n">gdf_routing</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">gdf_routing</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;sediout&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">})</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># merge routing to &#39;perceelskaart&#39;</span>
        <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">df_prckrt</span> <span class="o">=</span> <span class="n">df_prckrt</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">gdf_routing</span><span class="p">[[</span><span class="s2">&quot;sediout&quot;</span><span class="p">,</span> <span class="s2">&quot;lnduSource&quot;</span><span class="p">]],</span>
            <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">,</span>
            <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">df_prckrt</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_prckrt</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">(),</span> <span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>
        <span class="n">df_prckrt</span> <span class="o">=</span> <span class="n">df_prckrt</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;val&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_prckrt</span></div>


<div class="viewcode-block" id="PostProcess.couple_sediout_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.couple_sediout_routing">[docs]</a>
    <span class="k">def</span> <span class="nf">couple_sediout_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Couple sediout of raster map values to routing file.</span>

<span class="sd">        See :func:`pywatemsedem.postprocess.couple_sediout_routing`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gdf_routing_sediout: geopandas.GeoDataFrame</span>
<span class="sd">            See :func:`pywatemsedem.postprocess.couple_sediout_routing`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Coupling amount of sediment to routing vectors...&quot;</span><span class="p">)</span>
        <span class="n">valid_routing_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">gdf_routing_sediout</span> <span class="o">=</span> <span class="n">couple_sediout_routing</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span> <span class="n">cols_out</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_sediout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;_sediout.shp&quot;</span>
        <span class="p">)</span>
        <span class="n">gdf_routing_sediout</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_sediout</span><span class="p">)</span>
        <span class="n">create_spatial_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_sediout</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf_routing_sediout</span></div>


<div class="viewcode-block" id="PostProcess.intersect_sedioutparcels_with_subcatchments">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.intersect_sedioutparcels_with_subcatchments">[docs]</a>
    <span class="k">def</span> <span class="nf">intersect_sedioutparcels_with_subcatchments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">rst_subcatchment_sinks</span><span class="p">,</span> <span class="n">df_sediout_parcel</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the intersection between the subcatchments of the sinks and the</span>
<span class="sd">        parcels that lie within these subcatchments.</span>

<span class="sd">        The sediout_parcel map is used to identify the sediment exported out</span>
<span class="sd">        of a parcel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rst_subcatchment_sinks: str or pathlib.Path</span>
<span class="sd">            File path of the subcatcmsinks raster</span>
<span class="sd">        df_sediout_parcel: pandas.DataFrame</span>
<span class="sd">            DataFrame of the sediout parcel map. This map holds</span>
<span class="sd">            for every pixel the total amount of sediment</span>
<span class="sd">            that is transported outside the parcel in which the parcel lies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr_subcatchments</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_subcatchment_sinks</span><span class="p">)</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_subcatchments</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>

        <span class="c1"># remove pixels with value nodata and zero</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_subcatchments</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">df_subcatchments</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">df_subcatchments</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
        <span class="c1"># merge with sediout defined per parcel</span>
        <span class="n">df_subcatchments</span> <span class="o">=</span> <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">df_sediout_parcel</span><span class="p">[[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;lnduSource&quot;</span><span class="p">]],</span>
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">],</span>
            <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># get ids of parcels (lndSource, not equal to none, np.nan)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="o">~</span><span class="n">df_subcatchments</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>
        <span class="n">unique_ids</span> <span class="o">=</span> <span class="n">df_subcatchments</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="c1">#  set pixels that have no parcel_id (lnduSource) wihtin the</span>
        <span class="c1">#  unique_ids list to nodata</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">df_sediout_parcel</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">unique_ids</span><span class="p">)</span>
        <span class="n">df_sediout_parcel</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;SediOut&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>

        <span class="c1"># write to disk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="s2">&quot;SedoutSinks.tif&quot;</span>
        <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span>

        <span class="n">arr_sediout</span> <span class="o">=</span> <span class="n">raster_dataframe_to_arr</span><span class="p">(</span>
            <span class="n">df_sediout_parcel</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="s2">&quot;SediOut&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>

        <span class="n">write_arr_as_rst</span><span class="p">(</span>
            <span class="n">arr_sediout</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rst_sinks</span><span class="p">,</span>
            <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.select_routing_to_outsidecatchment">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.select_routing_to_outsidecatchment">[docs]</a>
    <span class="k">def</span> <span class="nf">select_routing_to_outsidecatchment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Exports all routing vectors to the outside of the catchment&quot;&quot;&quot;</span>
        <span class="n">valid_routing_sediout_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Determining routing out of the catchment...&quot;</span><span class="p">)</span>

        <span class="n">vct_out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span>
            <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;routing_to_outside_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">.shp&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vct_out</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">gdf_routingsediout</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_routingsediout</span><span class="p">)</span>
            <span class="n">gdf_routingsediout</span> <span class="o">=</span> <span class="n">gdf_routingsediout</span><span class="p">[</span><span class="n">gdf_routingsediout</span><span class="p">[</span><span class="s2">&quot;lnduTarg&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">gdf_routingsediout</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span>
            <span class="n">create_spatial_index</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.get_total_sediment">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.get_total_sediment">[docs]</a>
    <span class="k">def</span> <span class="nf">get_total_sediment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make nice output table</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            Sum statistic (columns `value`) for variables (indices).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_total_sediment</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;value (kg)&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="PostProcess.read_total_sediment">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.read_total_sediment">[docs]</a>
    <span class="k">def</span> <span class="nf">read_total_sediment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the total sediment file</span>

<span class="sd">        See :func:`pywatemsedem.utils.load_total_sediment_file`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict_total_sediment: dict</span>
<span class="sd">            See :func:`pywatemsedem.utils.load_total_sediment_file`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dict_total_sediment</span> <span class="o">=</span> <span class="n">load_total_sediment_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_total_sediment&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dict_total_sediment</span></div>


<div class="viewcode-block" id="PostProcess.assign_values_df_summary">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.assign_values_df_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">assign_values_df_summary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">df_summary</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">bekken</span><span class="p">,</span> <span class="n">bekken_id</span><span class="p">,</span> <span class="n">summary_values</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ton&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign values of summary to the summary dataframe</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df_summary: pandas.DataFrame</span>
<span class="sd">            Dataframe holding all summary values</span>
<span class="sd">        index: int</span>
<span class="sd">            Row index to write summary values to</span>
<span class="sd">        bekken: str</span>
<span class="sd">            Name of the (sub)catchemnt</span>
<span class="sd">        bekken_id: int</span>
<span class="sd">            Id of the bekken</span>
<span class="sd">        summary_values: dict</span>

<span class="sd">            - *erosion* (float): amount of netto erosion (watererosion &lt; 0)</span>
<span class="sd">            - *deposition* (float): amount of netto deposition (watererosion &gt;</span>
<span class="sd">              0)</span>
<span class="sd">            - *river* (float): amount of sediment load to river.</span>
<span class="sd">            - *outside_domain* (float): amount of sediment routed out of</span>
<span class="sd">              boundaries catchment</span>
<span class="sd">            - *buffers* (float): amount of sediment trapped in buffers.</span>
<span class="sd">            - *endpoints* (float): amount of sediment load to endpoints.</span>

<span class="sd">        unit: str, optional</span>
<span class="sd">            &#39;ton&#39; or &#39;kg&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        df_summary: pandas.DataFrame</span>
<span class="sd">            updated dataframe holding all summary values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;kg&quot;</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;ton&quot;</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="mi">1000</span>

        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;erosie&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;erosion&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;sedimentatie&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;deposition&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;rivier&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;river&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;waterloop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;river&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;doorvoerratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;river&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;erosion&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;buiten_domein&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;outside_domain&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;buffers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">summary_values</span><span class="p">[</span><span class="s2">&quot;buffers&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;bekken&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bekken</span>
        <span class="n">df_summary</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;bekken_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bekken_id</span>

        <span class="k">return</span> <span class="n">df_summary</span></div>


<div class="viewcode-block" id="PostProcess.process_buffers">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.process_buffers">[docs]</a>
    <span class="k">def</span> <span class="nf">process_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrite function&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_buffers</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_process_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compute_priority</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vct_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the ingoing, outgoing and depositing sediment in buffers.</span>

<span class="sd">        This function computes the efficiency (deposition = ingoing -</span>
<span class="sd">        outgoing) sediment per buffer. In addition, this result is</span>
<span class="sd">        mapped to a shape file. See</span>
<span class="sd">        :func:`pywatemsedem.postprocess.compute_efficiency_buffers` for an</span>
<span class="sd">        explanation of the algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compute_priority: bool, optional</span>
<span class="sd">            Compute priorities for buffers based on deposition</span>
<span class="sd">        cols: list</span>
<span class="sd">            List of geopandas.GeoDataFrame output columns.</span>
<span class="sd">        vct_out: str or pathlib.Path, default None</span>
<span class="sd">            File path to export. If none, exported to standard name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating how much sediment is trapped in each buffer...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span><span class="p">[</span><span class="s2">&quot;Include buffers&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">df_out</span> <span class="o">=</span> <span class="n">compute_efficiency_buffers</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_buffers&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediin&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">gdf_buffer</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_buffers&quot;</span><span class="p">])</span>
            <span class="n">gdf_buffer</span> <span class="o">=</span> <span class="n">gdf_buffer</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">df_out</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="n">gdf_buffer</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_buffer</span><span class="o">.</span><span class="n">area</span>
            <span class="k">if</span> <span class="n">compute_priority</span><span class="p">:</span>
                <span class="n">gdf_buffer</span> <span class="o">=</span> <span class="n">compute_cdf_sediment_load</span><span class="p">(</span>
                    <span class="n">gdf_buffer</span><span class="p">,</span>
                    <span class="s2">&quot;buff_sed&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
                    <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;buffers&quot;</span><span class="p">,</span>
                    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">vct_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vct_out</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_buffers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">gdf_buffer</span> <span class="o">=</span> <span class="n">gdf_buffer</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
            <span class="n">gdf_buffer</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">gdf_buffer</span>

<div class="viewcode-block" id="PostProcess.compute_netto_erosion_parcels">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.compute_netto_erosion_parcels">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_netto_erosion_parcels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the netto erosion per parcel.</span>

<span class="sd">        For an explanation of the definition of netto erosion,</span>
<span class="sd">        see :func:`pywatemsedem.postprocess.compute_netto_erosion_parcels`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        join: bool, optional</span>
<span class="sd">            Join the results of the netto erosion raster calculations to the</span>
<span class="sd">            parcel shape file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating netto erosion for every parcel...&quot;</span><span class="p">)</span>
        <span class="n">compute_netto_erosion_parcels</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_percelen_prcid&quot;</span><span class="p">],</span>
            <span class="n">resolution</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
            <span class="n">fmap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
            <span class="n">flag_write</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">flag_join_vct_parcels</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_process_grass_strips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compute_priority</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute graass strips efficiency and compute priority</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compute_priority: bool, optional</span>
<span class="sd">            Compute priorities for grass strips based on deposition in grass strip.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gdf_grass_strips: geopandas.GeoDataFrame</span>
<span class="sd">            See :func:`pywatemsedem.postprocess.compute_efficiency_grass_strips` added</span>
<span class="sd">            with columns (if compute_priority=True)</span>
<span class="sd">                - *gras_id_target* (float): grass_id</span>
<span class="sd">                - *gras_id_source* (float): grass_id</span>
<span class="sd">                - *npixels_t* (float: number of pixels of target grass strip</span>
<span class="sd">                - *sediin* (float): total incoming sediment in grass strip (kg)</span>
<span class="sd">                - *sediout* (float): total outgoing sediment out of grass strip (kg)</span>
<span class="sd">                - *eSTE* (float): estimated sediment trapping efficiency, see</span>
<span class="sd">                  :func:`pywatemsedem.grasstrips.estimate_ste` (%)</span>
<span class="sd">                - sed (float): amount of sedimentation (kg)</span>
<span class="sd">                - *column_value* (float): deposition in grass strip.</span>
<span class="sd">                - *cum_sum* (float): cumulative sum of deposition in grass strips</span>
<span class="sd">                - *cdf* (float): cumulative distribution estimate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating in- and output of sediment for every grass strip...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_ecm_options</span><span class="p">[</span><span class="s2">&quot;UseGras&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">df_grass_strips_eff</span> <span class="o">=</span> <span class="n">compute_efficiency_grass_strips</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_routing&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_grass_strips_id&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="n">gdf_grass_strips</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_grass_strips&quot;</span><span class="p">])</span>
            <span class="n">gdf_grass_strips</span> <span class="o">=</span> <span class="n">gdf_grass_strips</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">df_grass_strips_eff</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">compute_priority</span><span class="p">:</span>
                <span class="n">gdf_grass_strips</span> <span class="o">=</span> <span class="n">compute_cdf_sediment_load</span><span class="p">(</span>
                    <span class="n">gdf_grass_strips</span><span class="p">,</span>
                    <span class="s2">&quot;sed&quot;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">,</span>
                    <span class="n">ignore_negative_values</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;grass_strips&quot;</span><span class="p">,</span>
                    <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Can not process grass strips, &#39;UseGras&#39;-option is set off.&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">gdf_grass_strips</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">gdf_grass_strips</span>

<div class="viewcode-block" id="PostProcess.merge_sediout_and_cumulative">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.merge_sediout_and_cumulative">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_sediout_and_cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segments_to_retain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge SediOut.rst (sediment output on every land pixel) and</span>
<span class="sd">        Cumulative.rst (sediment output in every</span>
<span class="sd">        river pixel).</span>

<span class="sd">        It is possible to retain only certain river segments</span>
<span class="sd">        in the merged raster. Therefore a list with</span>
<span class="sd">        all segmentnumbers must be given to the parameter</span>
<span class="sd">        segements_to_retain. The segements not retained will get value</span>
<span class="sd">        0 in the resulting raster.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segments_to_retain: list</span>
<span class="sd">            list of ids of segments one wishes to retain in analysis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr_sediout_nonriver</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">])</span>
        <span class="n">arr_sediout_nonriver</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">arr_sediout_nonriver</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">],</span> <span class="n">arr_sediout_nonriver</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">arr_sediout_river</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_cumulative&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">segments_to_retain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># take all river segments, i.e. everything not nodata</span>
            <span class="n">arr_sediout_river</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">arr_sediout_river</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">],</span> <span class="n">arr_sediout_river</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># take only river segments in list</span>
            <span class="n">arr_riversegm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_riviersegm&quot;</span><span class="p">])</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">arr_riversegm</span><span class="p">,</span> <span class="n">segments_to_retain</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">arr_riversegm</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">)</span>
            <span class="n">arr_sediout_river</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">arr_sediout_river</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">arr_sediout_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arr_bindomain</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">arr_sediout_river</span> <span class="o">+</span> <span class="n">arr_sediout_nonriver</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">rst_out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span>
            <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;SediOut_merged_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">.tif&quot;</span>
        <span class="p">)</span>
        <span class="n">write_arr_as_rst</span><span class="p">(</span><span class="n">arr_sediout_total</span><span class="p">,</span> <span class="n">rst_out</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rstparams</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.convert_output_rsts_to_ton">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.convert_output_rsts_to_ton">[docs]</a>
    <span class="k">def</span> <span class="nf">convert_output_rsts_to_ton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the units for rasters sediout, sediin, sediexport and</span>
<span class="sd">        watereros from kg to ton.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rsts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediout&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediin&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sediexport&quot;</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="n">new_rsts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_kg&quot;</span><span class="p">,</span> <span class="s2">&quot;_ton&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rsts</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsts</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">rsts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">convert_arr_from_kg_to_ton</span><span class="p">(</span><span class="n">rsts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_rsts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>


<div class="viewcode-block" id="PostProcess.add_sediment_to_subcatchments">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.add_sediment_to_subcatchments">[docs]</a>
    <span class="k">def</span> <span class="nf">add_sediment_to_subcatchments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vct_subcatchments</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds the sediment input of every river segment to the corresponding</span>
<span class="sd">        subcatchment.</span>

<span class="sd">        For every subcatchment the attribute sedar is calculated. Sedar is</span>
<span class="sd">        calculated as sedimentinput/area subcatchment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vct_subcatchments: str or pathlib.Path</span>
<span class="sd">            File path of vectorfile which holds the subcatchments subject to</span>
<span class="sd">            inspection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Coupling results to subcatchments...&quot;</span><span class="p">)</span>
        <span class="n">vct_subcatchments</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span>

        <span class="n">df_segments</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_total_sediment_segments&quot;</span><span class="p">],</span>
            <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="s2">&quot;sediment&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">df_segments</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="n">df_segments</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span>
        <span class="p">)</span>  <span class="c1"># kg to tonnes</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">gdf_subcatchments</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;could not open </span><span class="si">{</span><span class="n">vct_subcatchments</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;NR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">]</span>
            <span class="n">gdf_subcatchments</span> <span class="o">=</span> <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">df_segments</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">area</span>
            <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;sedar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;sedar_ha&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatchments</span><span class="p">[</span><span class="s2">&quot;sedar&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">10000.0</span>
            <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;VALUE&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.add_segment_results_to_vct">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.add_segment_results_to_vct">[docs]</a>
    <span class="k">def</span> <span class="nf">add_segment_results_to_vct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds the sedimentinput to every riversegment and calculates the</span>
<span class="sd">        sedlen-argument.</span>

<span class="sd">        Sedlen is calculated as sedimentinput/length river segment.</span>

<span class="sd">        The resulting shapefile is stored in self.segmShp.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Coupling results to segments...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_total_sediment_segments&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_waterline&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">df_total_sediment_segments</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_total_sediment_segments&quot;</span><span class="p">],</span>
                <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="s2">&quot;Sediment&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">df_total_sediment_segments</span><span class="p">[</span><span class="s2">&quot;Sediment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">df_total_sediment_segments</span><span class="o">.</span><span class="n">Sediment</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span>
            <span class="p">)</span>  <span class="c1"># kg to tonnes</span>
            <span class="n">df_waterline</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_waterline&quot;</span><span class="p">])</span>
            <span class="n">df_waterline</span> <span class="o">=</span> <span class="n">df_waterline</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">df_total_sediment_segments</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="n">df_waterline</span><span class="p">[</span><span class="s2">&quot;sedlen&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_waterline</span><span class="p">[</span><span class="s2">&quot;Sediment&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df_waterline</span><span class="o">.</span><span class="n">length</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">vct_riversegment</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span>
                <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;Sedimentexport2Segments_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">_&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.shp&quot;</span>
            <span class="p">)</span>

            <span class="n">df_waterline</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_riversegment</span><span class="p">)</span>
            <span class="n">create_spatial_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vct_riversegment</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;txt_total_sediment_segments&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> or &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;vct_waterline&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not exist!&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.compute_sewer_in_per_catchment">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.compute_sewer_in_per_catchment">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_sewer_in_per_catchment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vct_subcatchments</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute sewer in per subcatchment</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vct_subcatchments: str or pathlib.Path</span>
<span class="sd">            File path of vectorfile which holds the subcatchments subject to</span>
<span class="sd">            inspection</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vct_subcatchments</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span>
        <span class="n">rst_subcatchment</span> <span class="o">=</span> <span class="n">vct_subcatchments</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span>
            <span class="n">vct_subcatchments</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;.sdat&quot;</span>
        <span class="p">)</span>
        <span class="n">arr_sewerin</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_sewerin&quot;</span><span class="p">])</span>
        <span class="n">arr_subcatchment</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_subcatchment</span><span class="p">)</span>
        <span class="n">sewer_in</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">catchids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr_subcatchment</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">catchid</span> <span class="ow">in</span> <span class="n">catchids</span><span class="p">:</span>
            <span class="n">sewerinsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_subcatchment</span> <span class="o">==</span> <span class="n">catchid</span><span class="p">,</span> <span class="n">arr_sewerin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sewer_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sewerinsum</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ids&quot;</span><span class="p">:</span> <span class="n">catchids</span><span class="p">,</span> <span class="s2">&quot;sewer_in&quot;</span><span class="p">:</span> <span class="n">sewer_in</span><span class="p">}</span>
        <span class="n">df_sewerin</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">df_sewerin</span><span class="p">[</span><span class="s2">&quot;sewer_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="n">df_sewerin</span><span class="p">[</span><span class="s2">&quot;sewer_in&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span>
        <span class="p">)</span>  <span class="c1"># kg to tonnes</span>
        <span class="n">gdf_subcatchments</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span>
        <span class="n">gdf_subcatchments</span> <span class="o">=</span> <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">df_sewerin</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;ids&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
        <span class="p">)</span>
        <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ids&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gdf_subcatchments</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_subcatchments</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.make_routing_vct">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.make_routing_vct">[docs]</a>
    <span class="k">def</span> <span class="nf">make_routing_vct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a routing vector file based on routingfile</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        extent: list</span>
<span class="sd">            list holding value of extent to consider, xmin,ymin,xmax,ymax</span>
<span class="sd">        tilenumber: int</span>
<span class="sd">            id of tile</span>
<span class="sd">        tag: str</span>
<span class="sd">            tag to add to filename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">txt_routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_routing&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_routing&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="n">tag</span> <span class="o">+</span> <span class="s2">&quot;.shp&quot;</span>
        <span class="p">)</span>
        <span class="n">make_routing_vct_saga</span><span class="p">(</span>
            <span class="n">txt_routing</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rstparams</span><span class="p">,</span>
            <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span>
            <span class="n">tile_number</span><span class="o">=</span><span class="n">tile_number</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.make_missing_routing_vct_saga">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.make_missing_routing_vct_saga">[docs]</a>
    <span class="k">def</span> <span class="nf">make_missing_routing_vct_saga</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a routing vector file based on routingfile with missing&quot;&quot;&quot;</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">txt_routing_missing</span>
        <span class="k">if</span> <span class="n">txt</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vct_routing_missing</span> <span class="o">=</span> <span class="n">make_routing_vct_saga</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="s2">&quot;missing_routing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.identify_sinks_in_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.identify_sinks_in_routing">[docs]</a>
    <span class="k">def</span> <span class="nf">identify_sinks_in_routing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify sinks based on whether more than one routing vector goes to</span>
<span class="sd">        a pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Looking for sinks in routing...&quot;</span><span class="p">)</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;txt_routing&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">txt</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="c1"># check if file is tab seperated</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">first_line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first_line</span><span class="p">:</span>
                <span class="n">df_routing</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
                    <span class="n">txt</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;;&quot;</span>
                <span class="p">)</span>  <span class="c1"># old model runs used ; as seperator in routing file</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_routing</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">txt</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">Cnst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span>
            <span class="c1"># df_route = df_route.loc[(df_route.target1row != -99) &amp; (</span>
            <span class="c1"># df_route.target2row != -99)].copy()</span>
            <span class="c1"># punten -99 zijn buiten modeldomein</span>

            <span class="n">arr_pfactor</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_pkaart&quot;</span><span class="p">])</span>
            <span class="n">df_pkaart</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_pfactor</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
            <span class="n">df_pkaart</span> <span class="o">=</span> <span class="n">df_pkaart</span><span class="p">[(</span><span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="p">[[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">df_routing</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">df_pkaart</span> <span class="o">=</span> <span class="n">df_pkaart</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_routing</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
            <span class="n">df_pkaart</span> <span class="o">=</span> <span class="n">df_pkaart</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">df_pkaart</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;sourceX&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;minmax&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">Cnst</span><span class="p">[</span>
                    <span class="s2">&quot;res&quot;</span>
                <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;sourceY&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;minmax&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">Cnst</span><span class="p">[</span>
                    <span class="s2">&quot;res&quot;</span>
                <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;nrows&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">])</span>
                <span class="n">df_pkaart</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_pkaart</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sourceX</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sourceY</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">CRS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;init&quot;</span><span class="p">:</span> <span class="n">Cnst</span><span class="p">[</span><span class="s2">&quot;epsg&quot;</span><span class="p">]}</span>
                <span class="n">gpd_bindomain</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                    <span class="n">df_pkaart</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">CRS</span>
                <span class="p">)</span>
                <span class="n">vct_out</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;sinks_in_routing_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">_s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.shp&quot;</span>
                <span class="p">)</span>

                <span class="n">vct_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="n">vct_out</span>
                <span class="n">gpd_bindomain</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gpd_bindomain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> sinks in routing!&quot;</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                cmd_args = [&#39;saga_cmd&#39;, &#39;shapes_grid&#39;, &#39;0&#39;, &#39;-SHAPES&#39;,</span>
<span class="sd">                str(outshp)]</span>
<span class="sd">                cmd_args += [&#39;-GRIDS&#39;, str(self.perceelRST[</span>
<span class="sd">                self.scenario.years[0]])]</span>
<span class="sd">                cmd_args += [&#39;-RESULT&#39;, str(outshp)]</span>
<span class="sd">                cmd_args += [&#39;-RESAMPLING&#39;, &#39;0&#39;]</span>
<span class="sd">                print(cmd_args)</span>
<span class="sd">                execute_subprocess(cmd_args)</span>
<span class="sd">                &quot;&quot;&quot;</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No sinks in routing&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;routing.txt does not exist!&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.set_prckrt_nodata">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.set_prckrt_nodata">[docs]</a>
    <span class="k">def</span> <span class="nf">set_prckrt_nodata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set nodata to &#39;WaTEM/SEDEM perceelskaart&#39;&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rst_prckrt_nodata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;_nodata.tif&quot;</span>
            <span class="n">set_no_data_rst</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">],</span> <span class="n">rst_prckrt_nodata</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;set_no_data_rst&#39; failed for WaTEM/SEDEM perceelskaart.&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CNWSException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;check if scenario is defined correctly&quot;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CNWSException</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.calculate_areas_prckrt">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.calculate_areas_prckrt">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_areas_prckrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the areas and relative areas of all landuse classes in</span>
<span class="sd">        the parcelmap</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_prckrt_nodata</span><span class="p">()</span>

        <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_prckrt&quot;</span><span class="p">])</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span>
        <span class="n">arr_prckrt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_prckrt</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr_prckrt</span><span class="p">)</span>
        <span class="n">vals</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">res</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">vals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">areas</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
        <span class="n">rel_areas</span> <span class="o">=</span> <span class="n">areas</span> <span class="o">/</span> <span class="n">total_area</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;lnduse_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;rel_area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_areas</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;opp_perceelskaart_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">_&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.csv&quot;</span>
        <span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.make_facts">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.make_facts">[docs]</a>
    <span class="k">def</span> <span class="nf">make_facts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a textfile with a number of stats about the simulation&quot;&quot;&quot;</span>
        <span class="n">factsfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span> <span class="o">/</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;facts_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="s2">_s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.csv&quot;</span>
        <span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">factsfile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">catchment_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">opp_catch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arr_bindomain</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arr_bindomain</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rstparams</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]]</span>
            <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rasterprop</span><span class="p">[</span><span class="s2">&quot;res&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">opp_catch_ha</span> <span class="o">=</span> <span class="n">opp_catch</span> <span class="o">/</span> <span class="mf">10000.0</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Oppervlakte bekken (ha);</span><span class="si">{</span><span class="n">opp_catch_ha</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">df_parcel</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_percelen&quot;</span><span class="p">])</span>
            <span class="n">n_parcels</span> <span class="o">=</span> <span class="n">df_parcel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Aantal landbouwpercelen </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">n_parcels</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">df_parcel</span><span class="p">[</span><span class="s2">&quot;opp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_parcel</span><span class="o">.</span><span class="n">area</span>
            <span class="n">opp_parcels</span> <span class="o">=</span> <span class="n">df_parcel</span><span class="o">.</span><span class="n">opp</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">opp_parcels_ha</span> <span class="o">=</span> <span class="n">opp_parcels</span> <span class="o">/</span> <span class="mf">10000.0</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Oppervlakte landbouwpercelen (ha) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">opp_parcels_ha</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># (SG/DR) share of agricultural parcels</span>
            <span class="n">aandeel_landbouw</span> <span class="o">=</span> <span class="p">(</span><span class="n">opp_parcels_ha</span> <span class="o">/</span> <span class="n">opp_catch_ha</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;relatieve opp landbouwpercelen (%) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">aandeel_landbouw</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;Lndgbrk&quot;</span> <span class="ow">in</span> <span class="n">df_parcel</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">n_nt_kerend</span> <span class="o">=</span> <span class="n">df_parcel</span><span class="p">[</span><span class="n">df_parcel</span><span class="o">.</span><span class="n">ntkerend</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Aantal nt-kerend bewerkte percelen </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">n_nt_kerend</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">df_grass</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;vct_grass_strips&quot;</span><span class="p">])</span>
            <span class="n">n_grass</span> <span class="o">=</span> <span class="n">df_grass</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Aantal grasstroken </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">year</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">n_grass</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PostProcess.split_sewerin">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.split_sewerin">[docs]</a>
    <span class="k">def</span> <span class="nf">split_sewerin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the sewerin raster with the sewer_id raster.</span>

<span class="sd">        See :func:`pywatemsedem.postprocess.split_endpoints_in_raster`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rst_sewers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">)</span>
            <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;endpoints_in_sewers_s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.rst&quot;</span>
        <span class="p">)</span>
        <span class="n">rst_ditches</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfolder</span><span class="o">.</span><span class="n">postprocess_folder</span><span class="p">)</span>
            <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;endpoints_in_ditches_s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_label</span><span class="si">}</span><span class="s2">.rst&quot;</span>
        <span class="p">)</span>

        <span class="n">split_endpoints_in_raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_endpoints_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_endpoints&quot;</span><span class="p">],</span>
            <span class="n">rst_sewers</span><span class="p">,</span>
            <span class="n">rst_ditches</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">rst_sewers</span><span class="p">,</span> <span class="n">rst_ditches</span></div>


<div class="viewcode-block" id="PostProcess.write_erosion_deposition_raster">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.PostProcess.write_erosion_deposition_raster">[docs]</a>
    <span class="k">def</span> <span class="nf">write_erosion_deposition_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write erosion and deposition ratser based on watereros&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_erosion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_erosion_raster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_deposition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_deposition_raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;rst_watereros&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="check_if_file_exists">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.check_if_file_exists">[docs]</a>
<span class="k">def</span> <span class="nf">check_if_file_exists</span><span class="p">(</span><span class="n">full_filename</span><span class="p">,</span> <span class="n">mandatory</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the specified file exist on disk</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    full_filename: str or pathlib.Path</span>
<span class="sd">        File path of the to check file</span>
<span class="sd">    mandatory: bool</span>
<span class="sd">        Indicate whether the file is mandatory or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        File exists (True/False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_filename</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mandatory</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Mandatory file &#39;</span><span class="si">{</span><span class="n">full_filename</span><span class="si">}</span><span class="s2">&#39; does not exist&quot;</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="split_endpoints_in_raster">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.split_endpoints_in_raster">[docs]</a>
<span class="k">def</span> <span class="nf">split_endpoints_in_raster</span><span class="p">(</span>
    <span class="n">rst_endpoints_id</span><span class="p">,</span> <span class="n">rst_endpoints_in</span><span class="p">,</span> <span class="n">rst_id1</span><span class="p">,</span> <span class="n">rst_id2</span><span class="p">,</span> <span class="n">ton</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split the endpoints raster (sewer_in WaTEM/SEDEM definition) file for each</span>
<span class="sd">    endpoints id present in the endpoints_id raster.</span>

<span class="sd">    The endpoints are split according to 1: the sewers and 2: the ditches.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_endpoints_id: str or pathlib.Path</span>
<span class="sd">        File path of sewer_id raster. This raster holds the values 1 and 2</span>
<span class="sd">    rst_endpoints_in: str or pathlib.Path</span>
<span class="sd">        File path of sewer_in raster. This raster holds the sediment transport values</span>
<span class="sd">        for every pixel defined with a 1 or 2.</span>
<span class="sd">    rst_id1: str of pathlib.Path</span>
<span class="sd">        File path of output raster with id equal to one.</span>
<span class="sd">    rst_id2: str of pathlib.Path</span>
<span class="sd">        File path of output raster with id equal to two.</span>
<span class="sd">    ton: bool, default False</span>
<span class="sd">        Convert to ton (True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_id1: float</span>
<span class="sd">        Total sediment load in id1</span>
<span class="sd">    sum_id2: float</span>
<span class="sd">        Total sediment load in id2</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Note that sewers in WaTEM/SEDEM are endpoints in pywatemsedem, such to make a distinction</span>
<span class="sd">    between sewers and ditches in pywatemsedem.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># load sewer id&#39;s and sewer in (kg per pixel)</span>
    <span class="n">arr_sewer_id</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_endpoints_id</span><span class="p">)</span>
    <span class="n">arr_sewer_in</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_endpoints_in</span><span class="p">)</span>

    <span class="c1"># sewers</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_sewer_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr_sewer_in</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">ton</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]]</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">write_arr_as_rst</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">rst_id1</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">sum_id1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]])</span>

    <span class="c1"># ditches</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_sewer_id</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">arr_sewer_in</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">ton</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]]</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="n">write_arr_as_rst</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">rst_id2</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">sum_id2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">!=</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">sum_id1</span><span class="p">,</span> <span class="n">sum_id2</span></div>



<div class="viewcode-block" id="compute_efficiency_grass_strips">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_efficiency_grass_strips">[docs]</a>
<span class="k">def</span> <span class="nf">compute_efficiency_grass_strips</span><span class="p">(</span>
    <span class="n">txt_routing</span><span class="p">,</span> <span class="n">rst_grass_strips</span><span class="p">,</span> <span class="n">rst_prckrt</span><span class="p">,</span> <span class="n">rst_sediout</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute statistics for grass strips:</span>

<span class="sd">    1. Compute the individual sediment input and output per routing element</span>
<span class="sd">    2. Compute the incoming and outgoing sediment per gras_id</span>
<span class="sd">    3. Compute the total incoming and outgoing sediment aggregated over all</span>
<span class="sd">       grass strips</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    txt_routing: str or pathlib.Path</span>
<span class="sd">        File path of the WaTEM/SEDEM routing table</span>
<span class="sd">    rst_grass_strips: str or ppathlib.Path</span>
<span class="sd">        raster grass strips with id&#39;s filename</span>
<span class="sd">    rst_prckrt: str or pathlib.Path</span>
<span class="sd">        raster CNWS perceelskaart</span>
<span class="sd">    rst_sediout: str or pathlib.Path</span>
<span class="sd">        File path WaTEM/SEDEM output raster &#39;SediOut_kg.rst&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sediment_load_grass_strips_in: float</span>
<span class="sd">        Total sediment load streaming into all gras strips (kg)</span>
<span class="sd">    sediment_load_grass_strips_out: float</span>
<span class="sd">        Total sediment load streaming out of all gras strips (kg)</span>
<span class="sd">    df_efficiency: pandas.DataFrame</span>

<span class="sd">        Sediment load flowing in and flowing out grass strip with the columns:</span>

<span class="sd">        - *gras_id_target* (float): grass_id</span>
<span class="sd">        - *gras_id_source* (float): grass_id</span>
<span class="sd">        - *npixels_t* (float: number of pixels of target grass strip</span>
<span class="sd">        - *sediin* (float): total incoming sediment in grass strip (kg)</span>
<span class="sd">        - *sediout* (float): total outgoing sediment out of grass strip (kg)</span>
<span class="sd">        - *eSTE* (float): estimated sediment trapping efficiency, see</span>
<span class="sd">          :func:`pywatemsedem.grasstrips.estimate_ste` (%)</span>
<span class="sd">        - sed (float): amount of sedimentation (kg)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    *gras_id_target* and *gras_id_source* are equal and refers to the gras_id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># load files</span>
    <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_prckrt</span><span class="p">)</span>
    <span class="n">df_prckrt</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">arr_grass_strips_id</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_grass_strips</span><span class="p">)</span>
    <span class="n">df_grass_strips</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_grass_strips_id</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>

    <span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile_sediout</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_sediout</span><span class="p">)</span>
    <span class="n">df_sediout</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile_sediout</span><span class="p">)</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">open_txt_routing_file</span><span class="p">(</span><span class="n">txt_routing</span><span class="p">)</span>

    <span class="c1"># filter grass strips that are actually modelled as grass strips in</span>
    <span class="c1"># pywatemsedem</span>
    <span class="n">df_grass_strips</span> <span class="o">=</span> <span class="n">filter_grass_strips_with_prckrt</span><span class="p">(</span>
        <span class="n">df_grass_strips</span><span class="p">,</span> <span class="n">df_prckrt</span><span class="p">,</span> <span class="n">profile</span>
    <span class="p">)</span>
    <span class="n">df_grass_strips</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_grass_strips</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># merge grass strips with sediout raster</span>
    <span class="n">df_routing_grasid</span> <span class="o">=</span> <span class="n">merge_grass_strip_id_and_sediout_to_routing</span><span class="p">(</span>
        <span class="n">df_grass_strips</span><span class="p">,</span> <span class="n">df_sediout</span><span class="p">,</span> <span class="n">df_routing</span>
    <span class="p">)</span>

    <span class="c1"># format df_routing_grass to a list format</span>
    <span class="n">df_routing_grass_T</span> <span class="o">=</span> <span class="n">reformat_routing_grass</span><span class="p">(</span><span class="n">df_routing_grasid</span><span class="p">)</span>

    <span class="c1"># aggregate per grass strip</span>
    <span class="n">df_efficiency</span> <span class="o">=</span> <span class="n">aggregate_sediin_and_sediout_grass_strips</span><span class="p">(</span><span class="n">df_routing_grass_T</span><span class="p">)</span>

    <span class="c1"># compute counts</span>
    <span class="n">arr_id</span><span class="p">,</span> <span class="n">arr_npixels_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr_grass_strips_id</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">df_counts</span><span class="p">[</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_id</span>
    <span class="n">df_counts</span><span class="p">[</span><span class="s2">&quot;npixels_t&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr_npixels_t</span>
    <span class="n">df_efficiency</span> <span class="o">=</span> <span class="n">df_efficiency</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_counts</span><span class="p">)</span>
    <span class="n">sediment_load_grass_strips_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediin&quot;</span><span class="p">])</span>
    <span class="n">sediment_load_grass_strips_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sediment_load_grass_strips_in</span><span class="p">,</span> <span class="n">sediment_load_grass_strips_out</span><span class="p">,</span> <span class="n">df_efficiency</span></div>



<div class="viewcode-block" id="aggregate_sediin_and_sediout_grass_strips">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.aggregate_sediin_and_sediout_grass_strips">[docs]</a>
<span class="k">def</span> <span class="nf">aggregate_sediin_and_sediout_grass_strips</span><span class="p">(</span><span class="n">df_routing_grass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the load in and out of a grass strips, so efficiencies can be</span>
<span class="sd">    computed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_routing_grass: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`:</span>

<span class="sd">        - *targetrow* (float): target row of pixel</span>
<span class="sd">        - *targetcol* (float) target column of pixel</span>
<span class="sd">        - *sediin* (float): incoming sediment pixel</span>
<span class="sd">        - *sediout* (float): outgoing sediment pixel</span>
<span class="sd">        - *gras_id_source* (float): grass strip id for source, -9999 if not a grass</span>
<span class="sd">          strip.</span>
<span class="sd">        - *gras_id_target* (float): grass strip id for target, -9999 if not a grass</span>
<span class="sd">          strip.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_efficiency: pandas.DataFrame</span>
<span class="sd">        Sediment load flowing in and flowing out grass strip with the columns:</span>

<span class="sd">        - *gras_id_target* (float): target grass_id</span>
<span class="sd">        - *gras_id_source* (float): target grass_id</span>
<span class="sd">        - *sediin* (float): incoming sediment in grass strip</span>
<span class="sd">        - *sediout* (float): outgoing sediment out of grass strip</span>
<span class="sd">        - *eSTE* (float): estimated sediment trapping efficiency, see</span>
<span class="sd">          :func:`pywatemsedem.grasstrips.estimate_ste`</span>
<span class="sd">        - *sed* (float): amount of sedimentation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *gras_id_target* and *gras_id_source* are equal and refers to the gras_id (target).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;gras_id_source&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">]</span>
    <span class="n">df_sediout_grass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_routing_grass</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
        <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;gras_id_source&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;sediout&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">df_sediin_grass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_routing_grass</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
        <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;sediout&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">df_sediin_grass</span> <span class="o">=</span> <span class="n">df_sediin_grass</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;sediout&quot;</span><span class="p">:</span> <span class="s2">&quot;sediin&quot;</span><span class="p">})</span>
    <span class="n">df_npixels</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_routing_grass</span><span class="p">[[</span><span class="s2">&quot;targetrow&quot;</span><span class="p">,</span> <span class="s2">&quot;targetcol&quot;</span><span class="p">,</span> <span class="s2">&quot;gras_id_target&quot;</span><span class="p">]]</span>
        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">df_efficiency</span> <span class="o">=</span> <span class="n">df_sediin_grass</span><span class="p">[[</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">,</span> <span class="s2">&quot;sediin&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">df_sediout_grass</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;gras_id_source&quot;</span>
    <span class="p">)</span>
    <span class="n">df_npixels</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">,</span> <span class="s2">&quot;npixels_r&quot;</span><span class="p">]</span>
    <span class="n">df_efficiency</span> <span class="o">=</span> <span class="n">df_efficiency</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_npixels</span><span class="p">)</span>
    <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;eSTE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimate_ste</span><span class="p">(</span>
        <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediin&quot;</span><span class="p">],</span> <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediin&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span>
    <span class="n">df_efficiency</span> <span class="o">=</span> <span class="n">df_efficiency</span><span class="p">[</span><span class="n">df_efficiency</span><span class="p">[</span><span class="s2">&quot;gras_id_target&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">9999</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df_efficiency</span></div>



<div class="viewcode-block" id="merge_grass_strip_id_and_sediout_to_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.merge_grass_strip_id_and_sediout_to_routing">[docs]</a>
<span class="k">def</span> <span class="nf">merge_grass_strip_id_and_sediout_to_routing</span><span class="p">(</span>
    <span class="n">df_grass_strips</span><span class="p">,</span>
    <span class="n">df_sediout</span><span class="p">,</span>
    <span class="n">df_routing</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge the id of the grass strips and the sediout (also pd list-format)</span>
<span class="sd">     to routing df.</span>

<span class="sd">    Filter grass strips which are not of landuse type -6 (&#39;weide&#39;) with &#39;WaTEM/SEDEM</span>
<span class="sd">    perceelskaart&#39;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_grass_strips: pandas.DataFrame</span>
<span class="sd">        - *col* (int): col</span>
<span class="sd">        - *row* (int): row</span>
<span class="sd">        - *val* (int): gras_id</span>

<span class="sd">    df_sediout: pandas.DataFrame</span>
<span class="sd">        - *col* (int): col</span>
<span class="sd">        - *row* (int): row</span>
<span class="sd">        - *val* (fload): outgoing sediment</span>

<span class="sd">    df_routing: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_routing_grass_id: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`,</span>
<span class="sd">        holding columns of df_routing and additional columns:</span>

<span class="sd">        - *gras_id_source* (int): gras_id value of the source pixel</span>
<span class="sd">        - *gras_id_target1* (int): gras_id value of the target1 pixel</span>
<span class="sd">        - *gras_id_target2* (int): gras_id value of the target2 pixel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare merge</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target1&quot;</span><span class="p">,</span> <span class="s2">&quot;target2&quot;</span><span class="p">]:</span>
        <span class="n">df_grass_strips</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;gras_id_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_grass_strips</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">target_id</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="n">df_grass_strips</span><span class="p">[</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;target</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">row&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;target</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">col&quot;</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">df_grass_strips</span><span class="p">[[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">]]</span>

    <span class="c1"># define sedout and index cols to join on</span>
    <span class="n">df_sediout</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sediout</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="n">df_sediout</span> <span class="o">=</span> <span class="n">df_sediout</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">])</span>

    <span class="c1"># join gras_id sources</span>
    <span class="n">df_routing_grass_id</span> <span class="o">=</span> <span class="n">merge_grass_id_to_routing</span><span class="p">(</span>
        <span class="n">df_routing</span><span class="p">,</span> <span class="n">df_grass_strips</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;gras_id_source&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># join sediout</span>
    <span class="n">df_routing_grass_id</span> <span class="o">=</span> <span class="n">df_routing_grass_id</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">df_sediout</span><span class="p">[[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">df_routing_grass_id</span> <span class="o">=</span> <span class="n">merge_grass_id_to_routing</span><span class="p">(</span>
        <span class="n">df_routing_grass_id</span><span class="p">,</span>
        <span class="n">df_grass_strips</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;target1col&quot;</span><span class="p">,</span> <span class="s2">&quot;target1row&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;gras_id_target1&quot;</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="c1"># joint gras ids targets</span>
    <span class="n">df_routing_grass_id</span> <span class="o">=</span> <span class="n">merge_grass_id_to_routing</span><span class="p">(</span>
        <span class="n">df_routing_grass_id</span><span class="p">,</span>
        <span class="n">df_grass_strips</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;target2col&quot;</span><span class="p">,</span> <span class="s2">&quot;target2row&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;gras_id_target2&quot;</span><span class="p">],</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">df_routing_grass_id</span></div>



<div class="viewcode-block" id="reformat_routing_grass">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.reformat_routing_grass">[docs]</a>
<span class="k">def</span> <span class="nf">reformat_routing_grass</span><span class="p">(</span><span class="n">df_routing_grass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reformat the routing_gras DataFrame</span>

<span class="sd">    Reformat the routing_gras dataframe so targets 1 and 2 are reported in</span>
<span class="sd">    the same column target.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_routing_grass: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_routing_grass_T: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`</span>

<span class="sd">        - *gras_id_target* (float): id of the routing target</span>
<span class="sd">        - *sediout* (float): sediment output pixel</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;sediout1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;part1&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;sediout2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="s2">&quot;part1&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">df1</span> <span class="o">=</span> <span class="n">select_and_rename_cols_grass_routing</span><span class="p">(</span><span class="n">df_routing_grass</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">df2</span> <span class="o">=</span> <span class="n">select_and_rename_cols_grass_routing</span><span class="p">(</span><span class="n">df_routing_grass</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">df_routing_grass_T</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df1</span><span class="p">,</span> <span class="n">df2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df_routing_grass_T</span></div>



<div class="viewcode-block" id="select_and_rename_cols_grass_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.select_and_rename_cols_grass_routing">[docs]</a>
<span class="k">def</span> <span class="nf">select_and_rename_cols_grass_routing</span><span class="p">(</span><span class="n">df_routing_grass</span><span class="p">,</span> <span class="n">target_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select and rename columns of grass strip routing geodataframe.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_routing_grass: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`</span>
<span class="sd">    target_id: int</span>
<span class="sd">        The number of the targets, can only be 1 or 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_routing_grass: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`,</span>
<span class="sd">        selected and renamed after target1 or target2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;target</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">row&quot;</span><span class="p">:</span> <span class="s2">&quot;targetrow&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;target</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">col&quot;</span><span class="p">:</span> <span class="s2">&quot;targetcol&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;sediout</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;sediout&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;gras_id_target</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;gras_id_target&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">df_routing_grass</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;part</span><span class="si">{</span><span class="n">target_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">df_routing_grass</span> <span class="o">=</span> <span class="n">df_routing_grass</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">cond</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;gras_id_source&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_routing_grass</span></div>



<div class="viewcode-block" id="filter_grass_strips_with_prckrt">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.filter_grass_strips_with_prckrt">[docs]</a>
<span class="k">def</span> <span class="nf">filter_grass_strips_with_prckrt</span><span class="p">(</span><span class="n">df_grass_strips</span><span class="p">,</span> <span class="n">df_prckrt</span><span class="p">,</span> <span class="n">profile_grass_strips</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the CNWS &#39;perceelskaart&#39; to filter grass strips (lay-over infr. and</span>
<span class="sd">    river cells over gras_buffer_id)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_grass_strips: pandas.DataFrame</span>
<span class="sd">        see</span>
<span class="sd">        :func:`pywatemsedem.postprocess.merge_grass_strip_id_and_sediout_to_routing`</span>
<span class="sd">    df_prckrt: pandas.DataFrame</span>

<span class="sd">        - *col* (int): col</span>
<span class="sd">        - *row* (int): row</span>
<span class="sd">        - *val* (float): WaTEM/SEDEM perceelskaart id.</span>

<span class="sd">    profile_grass_strips: rasterio.profiles</span>
<span class="sd">        see :func:`rasterio.open`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_grass_strips: pandas.DataFrame</span>
<span class="sd">        filtered data, see</span>
<span class="sd">        :func:`pywatemsedem.postprocess.merge_grass_strip_id_and_sediout_to_routing`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df_grass_strips</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_prckrt</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;val&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">profile_grass_strips</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df_grass_strips</span></div>



<div class="viewcode-block" id="merge_grass_id_to_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.merge_grass_id_to_routing">[docs]</a>
<span class="k">def</span> <span class="nf">merge_grass_id_to_routing</span><span class="p">(</span><span class="n">df_routing</span><span class="p">,</span> <span class="n">df_grass_strips</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge the gras_id with the source, target1 and target2 pixels</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_routing: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file`</span>
<span class="sd">    df_grass_strips: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.postprocess.merge_grass_strip_id_and_sediout_to_routing`</span>
<span class="sd">    cols: list</span>
<span class="sd">        Cols to consider for join</span>
<span class="sd">    field: str</span>
<span class="sd">        Column to use of df_grass_strips to do join</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_routing_merged: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.process_output.open_txt_routing_file` with</span>

<span class="sd">        TO DO</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">df_grass_strips</span> <span class="o">=</span> <span class="n">df_grass_strips</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">df_routing_merged</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_grass_strips</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_routing_merged</span></div>



<div class="viewcode-block" id="get_stats_ktc">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.get_stats_ktc">[docs]</a>
<span class="k">def</span> <span class="nf">get_stats_ktc</span><span class="p">(</span><span class="n">rst_ktc</span><span class="p">,</span> <span class="n">rst_prckrt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get statistics ktc-raster for specific land-uses</span>

<span class="sd">    The mean and  standard deviation of the ktc raster is computed,</span>
<span class="sd">    for the lande-use &#39;agriculture&#39; and &#39;grass strips&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_ktc: str or pathlib.Path</span>
<span class="sd">        File path of ktc raster.</span>
<span class="sd">    rst_prckrt: str or pathlib.Path</span>
<span class="sd">        File path WaTEM/SEDEM &#39;perceelskaart&#39; raster</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: dictionary</span>
<span class="sd">        Dictionary with statistics of ktc for all agriculture and grass strip (gs)</span>
<span class="sd">        pixels. Keys:</span>

<span class="sd">        - *mean_ktc_agr* (float): mean ktc value of all agriculture pixels.</span>
<span class="sd">        - *std_ktc_agr* (float): standard deviation of all agriculture pixels.</span>
<span class="sd">        - *mean_ktc_gs* (float): median ktc value of all grass strip pixels.</span>
<span class="sd">        - *std_ktc_gs* (float): standard deviation of all grass strip pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_prckrt</span><span class="p">)</span>
    <span class="n">arr_ktc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_ktc</span><span class="p">)</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">arr_prckrt</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;mean_ktc_agr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;std_ktc_agr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">arr_prckrt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;mean_ktc_gs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;std_ktc_gs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="get_stats_cfactor">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.get_stats_cfactor">[docs]</a>
<span class="k">def</span> <span class="nf">get_stats_cfactor</span><span class="p">(</span><span class="n">rst_cfactor</span><span class="p">,</span> <span class="n">rst_prckrt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get statistics ktc-raster for specific land-uses</span>

<span class="sd">    The mean and standard deviation of the cfactor raster is computed,</span>
<span class="sd">    for the lande-use &#39;agriculture&#39; and &#39;grass strips.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_cfactor: str or pathlib.Path</span>
<span class="sd">        File path of ktc raster.</span>
<span class="sd">    rst_prckrt: str or pathlib.Path</span>
<span class="sd">        File path of WaTEM/SEDEM &#39;perceelskaart&#39; raster</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: dictionary</span>
<span class="sd">        Dictionary with statistics of ktc for all agriculture and grass strip (gs)</span>
<span class="sd">        pixels. Keys:</span>

<span class="sd">        - *mean_cfactor_agr* (float): mean ktc value of all agriculture pixels.</span>
<span class="sd">        - *std_cfactor_agr* (float): standard deviation of all agriculture pixels.</span>
<span class="sd">        - *mean_cfactor_gs* (float): median ktc value of all grass strip pixels.</span>
<span class="sd">        - *std_cfactor_gs* (float): standard deviation of all grass strip pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_prckrt</span><span class="p">)</span>
    <span class="n">arr_ktc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_cfactor</span><span class="p">)</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">arr_prckrt</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;mean_cfactor_agr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;std_cfactor_agr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="n">arr_prckrt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;mean_cfactor_gs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">output</span><span class="p">[</span><span class="s2">&quot;std_cfactor_gs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_ktc</span><span class="p">[</span><span class="n">cond</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="compute_netto_erosion_parcels">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_netto_erosion_parcels">[docs]</a>
<span class="k">def</span> <span class="nf">compute_netto_erosion_parcels</span><span class="p">(</span>
    <span class="n">rst_prckrt</span><span class="p">,</span>
    <span class="n">rst_watereros</span><span class="p">,</span>
    <span class="n">rst_parcels_ids</span><span class="p">,</span>
    <span class="n">resolution</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">fmap</span><span class="o">=</span><span class="s2">&quot;results&quot;</span><span class="p">,</span>
    <span class="n">flag_write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">flag_join_vct_parcels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the netto erosion for every parcel.</span>

<span class="sd">    Computes the netto erosion for every parcel by identifying the pixels</span>
<span class="sd">    netto erosion in a parcel and summing up these values. Netto erosion</span>
<span class="sd">    values are defined in the watereros raster, in which netto erosion is</span>
<span class="sd">    defined as a negative number, and netto deposition is defined as a</span>
<span class="sd">    positive number. Only negative numbers are considered for the</span>
<span class="sd">    computation of netto erosion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_prckrt: string or pathlib.Path</span>
<span class="sd">        File path of the CNWS modelinput perceelskaart, note that the</span>
<span class="sd">        parcels_ids are limited by int16 (for WaTEM/SEDEM Pascal)</span>
<span class="sd">    rst_watereros: string or pathlib.Path</span>
<span class="sd">        File path of the CNWS modelouput watereros map</span>
<span class="sd">    rst_parcels_ids: string or pathlib.Path</span>
<span class="sd">        File path of the rasterfile holding the parcels_ids, not limited by</span>
<span class="sd">        int16</span>
<span class="sd">    resolution: int, default 20</span>
<span class="sd">    fmap: str, optional, default &#39;results&#39;</span>
<span class="sd">        Output map</span>
<span class="sd">    flag_write: bool, default False</span>
<span class="sd">        Flag to indicate whether results should be written to disk</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_netto_erosion: pandas.DataFrame</span>
<span class="sd">        DataFrame holding statistics for every parcel with the columns:</span>

<span class="sd">        - *sum_netto_erosion* (float): total netto erosion (ton/pixel/year)</span>
<span class="sd">        - *average_netto_erosion* (float): mean netto erosion (ton/ha/year)</span>
<span class="sd">        - *std_dev_netto_erosion* (float): standard deviation netto erosion</span>
<span class="sd">          (kg/pixel/year)</span>
<span class="sd">        - *arr_parcel* (float): area of parcel (ha)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    1. Two rasters of the WaTEM/SEDEM perceelskaart are feeded to this function. The</span>
<span class="sd">    first one is a int16, the other is float64. The float64 parcel id&#39;s are</span>
<span class="sd">    used over the int16, because they go higher in maximum value. This is</span>
<span class="sd">    relevant for doing the analysis on large catchments.</span>

<span class="sd">    2. For details on the computation of netto erosion per parcel, see</span>
<span class="sd">    :func:`pywatemsedem.postprocess.compute_netto_ero_prckrt`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># make output dir</span>
    <span class="n">fmap</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fmap</span><span class="p">)</span>
    <span class="n">fmap</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># load data</span>
    <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_prckrt</span><span class="p">)</span>
    <span class="n">arr_parcels_ids</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_parcels_ids</span><span class="p">)</span>
    <span class="n">arr_watereros</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_watereros</span><span class="p">)</span>

    <span class="c1"># compute netto erosion arr with statistics per parcel</span>
    <span class="n">dict_netto_ero</span> <span class="o">=</span> <span class="n">compute_netto_ero_prckrt</span><span class="p">(</span>
        <span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">arr_watereros</span><span class="p">,</span> <span class="n">arr_parcels_ids</span><span class="p">,</span> <span class="n">resolution</span>
    <span class="p">)</span>

    <span class="c1"># transform to dataframe and write to disk</span>
    <span class="n">df_netto_erosion</span> <span class="o">=</span> <span class="n">transform_dict_netto_erosion_to_df</span><span class="p">(</span><span class="n">dict_netto_ero</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flag_join_vct_parcels</span><span class="p">:</span>
        <span class="n">rst_parcels_ids</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">rst_parcels_ids</span><span class="p">)</span>
        <span class="n">vct_prcln</span> <span class="o">=</span> <span class="n">rst_parcels_ids</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rst_parcels_ids</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.shp&quot;</span><span class="p">)</span>
        <span class="n">gdf_prcln</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_prcln</span><span class="p">)</span>
        <span class="n">gdf_prcln</span> <span class="o">=</span> <span class="n">gdf_prcln</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">df_netto_erosion</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;NR&quot;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;prc_id&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gdf_prcln</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">flag_write</span><span class="p">:</span>
        <span class="n">txt_out</span> <span class="o">=</span> <span class="n">fmap</span> <span class="o">/</span> <span class="p">(</span><span class="s2">&quot;netto_erosion.csv&quot;</span><span class="p">)</span>
        <span class="n">df_netto_erosion</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">txt_out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flag_join_vct_parcels</span><span class="p">:</span>
            <span class="n">vct_out</span> <span class="o">=</span> <span class="n">fmap</span> <span class="o">/</span> <span class="s2">&quot;netto_erosion_parcels.shp&quot;</span>
            <span class="n">gdf_prcln</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_netto_erosion</span><span class="p">,</span> <span class="n">gdf_prcln</span></div>



<div class="viewcode-block" id="compute_netto_ero_prckrt">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_netto_ero_prckrt">[docs]</a>
<span class="k">def</span> <span class="nf">compute_netto_ero_prckrt</span><span class="p">(</span><span class="n">arr_prckrt</span><span class="p">,</span> <span class="n">arr_watereros</span><span class="p">,</span> <span class="n">arr_parcels_ids</span><span class="p">,</span> <span class="n">resolution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the netto erosion for every parcel.</span>

<span class="sd">    Compute the netto erosion for all parcels defined in the parcel raster.</span>

<span class="sd">        - Set all pixels where sedimentation (arr_watereros&gt;0) in arr_prckrt</span>
<span class="sd">          occurs to zero.</span>
<span class="sd">        - Identify all pixels in arr_prckrt with the same parcel id.</span>
<span class="sd">        - Compute the sum, mean and standerd deviation of the netto erosion is</span>
<span class="sd">          computed for all selected pixels (only where erosion occurs) in the</span>
<span class="sd">          considered parcel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr_prckrt: numpy.ndarray</span>
<span class="sd">        WaTEM/SEDEM modelinput perceelskaart</span>
<span class="sd">    arr_watereros: numpy.ndarray</span>
<span class="sd">        WaTEM/SEDEM modelouput watereros map</span>
<span class="sd">    arr_parcels_ids: numpy.ndarray</span>
<span class="sd">        Array of raster format of parcels shapefile</span>
<span class="sd">    resolution: int</span>
<span class="sd">        Raster resolution</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict_netto_ero: dict</span>
<span class="sd">        {key:value} = {parcel_id:lst_statistics}</span>

<span class="sd">        - parcel id: int</span>
<span class="sd">        - lst_statistics: list containing of the following elements:</span>

<span class="sd">            - *total_netto_erosion* (float): total netto erosion (</span>
<span class="sd">              ton/pixel/year)</span>
<span class="sd">            - *mean_netto_erosion* (float): mean netto erosion (ton/ha/year)</span>
<span class="sd">            - *std_dev_netto_erosion* (float): standard deviation netto</span>
<span class="sd">              erosion (kg/pixel/year)</span>
<span class="sd">            - *arr_parcel* (float): area of parcel (ha)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>

<span class="sd">    1. The watereros raster defines netto erosion and deposition. There are two cases</span>
<span class="sd">       that exist:</span>

<span class="sd">        - The total available sediment :math:`S_A` is smaller (or equal)</span>
<span class="sd">          than the transport capacity :math:`TC`. In this case **netto erosion** will</span>
<span class="sd">          occur at the rate of the mean annual soil rate (computed by RUSLE).</span>
<span class="sd">        - The available sediment :math:`S_A` is larger than the transport capacity</span>
<span class="sd">          :math:`TC`. If</span>
<span class="sd">          the incoming sediment :math:`S_i` is higher than :math:`TC` than</span>
<span class="sd">          **netto deposition** will</span>
<span class="sd">          occur :math:`S_i-TC`. If the :math:`S_i` is lower than :math:`TC` than</span>
<span class="sd">          **netto erosion** will occur at :math:`TC-S_i`</span>

<span class="sd">    2. The id&#39;s of the percelen raster is used to loop, and not the id&#39;s in the</span>
<span class="sd">    WaTEM/SEDEM perceelskaart. This format is used, as the end product should make</span>
<span class="sd">    statements on the level of parcels raster and not the &#39;WaTEM/SEDEM</span>
<span class="sd">    perceelskaart&#39; (the parcels raster differs from the WaTEM/SEDEM perceelskaart,</span>
<span class="sd">    in the way it only contains information of parcels, and not other land</span>
<span class="sd">    covers).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prc_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">arr_parcels_ids</span><span class="p">)</span>
    <span class="n">dict_netto_ero</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">condition_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">arr_prckrt</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">condition_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_prckrt</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">condition_1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">prc_id</span> <span class="ow">in</span> <span class="n">prc_ids</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prc_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># extract all forest, agriculture and grass land pixels</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">arr_parcels_ids</span> <span class="o">==</span> <span class="n">prc_id</span><span class="p">,</span> <span class="n">condition_1</span><span class="p">)</span>

            <span class="n">arr_netto_ero_parcel</span> <span class="o">=</span> <span class="n">arr_watereros</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span>
            <span class="n">arr_netto_ero_parcel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">arr_netto_ero_parcel</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr_netto_ero_parcel</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr_netto_ero_parcel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dict_netto_ero</span><span class="p">[</span><span class="n">prc_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_netto_ero_parcel</span><span class="p">(</span>
                    <span class="n">arr_netto_ero_parcel</span><span class="p">,</span> <span class="n">resolution</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">dict_netto_ero</span></div>



<div class="viewcode-block" id="compute_netto_ero_parcel">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_netto_ero_parcel">[docs]</a>
<span class="k">def</span> <span class="nf">compute_netto_ero_parcel</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span><span class="p">,</span> <span class="n">resolution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute netto erosion for one parcel.</span>

<span class="sd">    Compute the netto erosion for one parcel (only zero or non negative</span>
<span class="sd">    values). Negative values imply that no erosion or net deposition occurs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr_netto_erosion_parcel: numpy.ndarray</span>
<span class="sd">        Numpy array with netto erosion values (&lt;=0) for pixels of one parcel</span>
<span class="sd">    resolution: int</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        List with total, mean, std dev netto erosion for array, and area of</span>
<span class="sd">        the array</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>

<span class="sd">    1. The formula for the netto erosion per parcel (:math:`NE_{parcel}`) is</span>
<span class="sd">    the following</span>

<span class="sd">    .. math::</span>

<span class="sd">        NE_{parcel} = (1/n) sum_i^n (NE_i)/res^2</span>

<span class="sd">    with:</span>
<span class="sd">        - :math:`NE_i`: netto erosion for pixel :math:`i` (:math:`n` pixels in</span>
<span class="sd">          parcel) (ton/year). This netto erosion is derived from the watereros</span>
<span class="sd">          raster, in which positive values (deposition) are set to zero.</span>
<span class="sd">        - :math:`res`: model resulution (m).</span>

<span class="sd">    2. The array arr_netto_erosion_parcel can only contain non-positive</span>
<span class="sd">    numbers, as it only takes into account netto erosion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Netto erosion parcels array contains positive values, this is&quot;</span>
            <span class="s2">&quot;not possible. Please redefine the netto erosion parcels array.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># kg/cell/year to ton/cell/year</span>
    <span class="n">total_netto_erosion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>
    <span class="c1"># kg/cel/year to ton/ha/year</span>
    <span class="n">mean_netto_erosion</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.0</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">resolution</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">1000.0</span>
    <span class="p">)</span>
    <span class="c1"># kg/cell</span>
    <span class="n">std_dev_netto_erosion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span><span class="p">)</span>

    <span class="c1"># compute area of parcel (ha)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr_netto_erosion_parcel</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">/</span> <span class="mf">100.0</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">area_parcel</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">resolution</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">total_netto_erosion</span><span class="p">,</span> <span class="n">mean_netto_erosion</span><span class="p">,</span> <span class="n">std_dev_netto_erosion</span><span class="p">,</span> <span class="n">area_parcel</span><span class="p">]</span></div>



<div class="viewcode-block" id="transform_dict_netto_erosion_to_df">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.transform_dict_netto_erosion_to_df">[docs]</a>
<span class="k">def</span> <span class="nf">transform_dict_netto_erosion_to_df</span><span class="p">(</span><span class="n">dict_netto_ero</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform dictionary of netto erosion to a pandas dataframe format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dict_netto_ero: dict</span>
<span class="sd">        {key:value} = {parcel_id:lst_statistics}</span>

<span class="sd">        - parcel id: int</span>
<span class="sd">        - lst_statistics: list containing of the following elements:</span>

<span class="sd">            - *total_netto_erosion* (float): total netto erosion (</span>
<span class="sd">              ton/pixel/year)</span>
<span class="sd">            - *mean_netto_erosion* (float): mean netto erosion (ton/ha/year)</span>
<span class="sd">            - *std_dev_netto_erosion* (float): standard deviation netto</span>
<span class="sd">              erosion (kg/pixel/year)</span>
<span class="sd">            - *arr_parcel* (float): area of parcel (ha)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_netto_erosion: pandas.DataFrame</span>
<span class="sd">        Holding statistics for every parcel according to dict_netto_ero</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lst_columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;sum_netto_erosion&quot;</span><span class="p">,</span>
        <span class="s2">&quot;average_netto_erosion&quot;</span><span class="p">,</span>
        <span class="s2">&quot;std_dev_netto_erosion&quot;</span><span class="p">,</span>
        <span class="s2">&quot;area_parcel&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">df_netto_erosion</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
        <span class="n">dict_netto_ero</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">lst_columns</span>
    <span class="p">)</span>
    <span class="n">df_netto_erosion</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;prc_id&quot;</span>

    <span class="k">return</span> <span class="n">df_netto_erosion</span></div>



<div class="viewcode-block" id="identify_subcatchments_to_buffers">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.identify_subcatchments_to_buffers">[docs]</a>
<span class="k">def</span> <span class="nf">identify_subcatchments_to_buffers</span><span class="p">(</span>
    <span class="n">rst_buffers</span><span class="p">,</span>
    <span class="n">vct_buffers</span><span class="p">,</span>
    <span class="n">txt_routing_nonriver</span><span class="p">,</span>
    <span class="n">resmap</span><span class="p">,</span>
    <span class="n">profile</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify subcatchment to each one of the buffers</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_buffers: str or pathlib.Path</span>
<span class="sd">        File path of WaTEM/SEDEM buffer raster</span>
<span class="sd">    vct_buffers: str or pathlib.Path</span>
<span class="sd">        File path of buffers polygons</span>
<span class="sd">    txt_routing_nonriver: str or pathlib.Path</span>
<span class="sd">        File path of the WaTEM/SEDEM routing table without river routing included</span>
<span class="sd">    resmap: str or pathlib.Path</span>
<span class="sd">        Folder path of results folder</span>
<span class="sd">    profile: rasterio.profiles</span>
<span class="sd">            see :func:`rasterio.open`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr_buffer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_buffers</span><span class="p">)</span>
    <span class="n">gdf_buffers</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_buffers</span><span class="p">)</span>
    <span class="n">outlet_ids</span> <span class="o">=</span> <span class="n">gdf_buffers</span><span class="p">[</span><span class="s2">&quot;BUF_ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">arr_buffer</span><span class="p">,</span> <span class="n">outlet_ids</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr_buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">arr_outlet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">arr_buffer</span><span class="p">,</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">rst_outlet</span> <span class="o">=</span> <span class="n">resmap</span> <span class="o">/</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rst_buffers</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_outlet.rst&quot;</span><span class="p">)</span>
    <span class="n">rstparams</span> <span class="o">=</span> <span class="n">rasterprofile_to_rstparams</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>

    <span class="n">write_arr_as_rst</span><span class="p">(</span><span class="n">arr_outlet</span><span class="p">,</span> <span class="n">rst_outlet</span><span class="p">,</span> <span class="n">arr_outlet</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">rstparams</span><span class="p">)</span>

    <span class="n">define_subcatchments_saga</span><span class="p">(</span>
        <span class="n">rst_outlet</span><span class="p">,</span>
        <span class="n">txt_routing_nonriver</span><span class="p">,</span>
        <span class="n">resmap</span><span class="p">,</span>
        <span class="n">profile</span><span class="p">,</span>
        <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;catchments_to_buffers&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="compute_cdf_sediment_load">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_cdf_sediment_load">[docs]</a>
<span class="k">def</span> <span class="nf">compute_cdf_sediment_load</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">column_value</span><span class="p">,</span>
    <span class="n">resmap</span><span class="p">,</span>
    <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">no_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ignore_negative_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the cdf of sediment load in &#39;column_value&#39; in the dataframe df</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df: pandas.DataFrame</span>
<span class="sd">        Dataframe to compute cdf for</span>
<span class="sd">        - *column_value* (float): sediment load values</span>
<span class="sd">    column_value: str</span>
<span class="sd">        Column in &#39;df&#39; to compute cdf for</span>
<span class="sd">    resmap: str or pathlib.Path</span>
<span class="sd">        Folder path to which write figure to</span>
<span class="sd">    no_data: float, optional</span>
<span class="sd">        No_data value in &#39;column_value&#39;</span>
<span class="sd">    ignore_negative_values: float, optional</span>
<span class="sd">        Ignore negative values in column_value</span>
<span class="sd">    plot: str, optional</span>
<span class="sd">        Write plot to disk (True/False)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df: pandas.DataFrame</span>
<span class="sd">        Updated dataframe with cdf</span>

<span class="sd">        - *column_value* (float): sediment load values</span>
<span class="sd">        - *cum_sum* (float): cumulative sum of sediment load</span>
<span class="sd">        - *cdf* (float): cumulative distribution estimate</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate cumulative sum, in percentage</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_value</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">no_data</span>
    <span class="k">if</span> <span class="n">ignore_negative_values</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">]))</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cum_sum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cdf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">100</span> <span class="o">*</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="s2">&quot;cum_sum&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">,</span> <span class="n">column_value</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">resmap</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;cumulative_sedimentload_</span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">resmap</span> <span class="o">/</span> <span class="s2">&quot;cumulative_sedimentload.png&quot;</span>
        <span class="n">plot_cumulative_sedimentload</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">],</span> <span class="n">fname</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="couple_sediout_routing">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.couple_sediout_routing">[docs]</a>
<span class="k">def</span> <span class="nf">couple_sediout_routing</span><span class="p">(</span><span class="n">vct_routing</span><span class="p">,</span> <span class="n">rst_sediout</span><span class="p">,</span> <span class="n">epsg</span><span class="p">,</span> <span class="n">cols_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Couple the sediout raster values to the vector routing file</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vct_routing: str or pathlib.Path</span>
<span class="sd">        File path of vector routing, see</span>
<span class="sd">        :func:`pywatemsedem.io.modeloutput.make_routing_vct`</span>
<span class="sd">    rst_sediout: str or pathlib.Path</span>
<span class="sd">        File path WaTEM/SEDEM output raster &#39;SediOut_kg.rst&#39;</span>
<span class="sd">    epsg: str</span>
<span class="sd">        Format &quot;EPSG:XXXXX&quot;</span>
<span class="sd">    cols_out: list, optional</span>
<span class="sd">        Columns to output</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gdf_routing: geopandas.GeoDataFrame</span>
<span class="sd">        Loaded vector file, for format</span>
<span class="sd">        see :func:`pywatemsedem.io.modeloutput.make_routing_vct`. Columns</span>
<span class="sd">        added:</span>

<span class="sd">        - *sediout* (float): Total Sediment output (scale:parcel) from pixel</span>
<span class="sd">        - *sediout1* (float): Sediment output coupled to arrow current pixel</span>
<span class="sd">        - *sediout2* (float): Sedimout output coupled to other output arrow current</span>
<span class="sd">          pixel</span>
<span class="sd">        - *cum_sum* (float): Cumulative sediment output based on sediout1</span>
<span class="sd">        - *cum_perc* (float): Cumulative percentage (%)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_routing</span><span class="p">)</span>

    <span class="c1"># load sedOut</span>
    <span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_sediout</span><span class="p">)</span>
    <span class="n">df_sediout</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">df_sediout</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_sediout</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># merge sediout to routing</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">df_sediout</span><span class="p">[[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;sediout&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
    <span class="p">)</span>

    <span class="c1"># (DR) sediout correction with part (%): sediout is total amount that goes out a</span>
    <span class="c1"># pixel (derived over two pixels).</span>
    <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;part&quot;</span><span class="p">]</span>
    <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;part&quot;</span><span class="p">])</span>

    <span class="c1"># (DR) Write cumulative percentage (descending)</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;sediout1&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;cum_sum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;cum_perc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gdf_routing</span><span class="o">.</span><span class="n">cum_sum</span> <span class="o">/</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;sediout1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cols_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="n">cols_out</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">gdf_routing</span></div>



<div class="viewcode-block" id="select_routing_out_of_parcel">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.select_routing_out_of_parcel">[docs]</a>
<span class="k">def</span> <span class="nf">select_routing_out_of_parcel</span><span class="p">(</span><span class="n">gdf_routing</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Select routing vectors defined over borders parcel</span>

<span class="sd">    Only select the routing vector which cross the parcel border.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gdf_routing: geopandas.GeoDataFrame</span>
<span class="sd">        Loaded routing vector file (with or without sediout coupled to it).</span>
<span class="sd">        See :func:`pywatemsedem.io.modeloutput.make_routing_vct`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gdf_routing: geopandas.GeoDataFrame</span>
<span class="sd">        Selected routing vector file (with or without sediout coupled to it).</span>
<span class="sd">        See :func:`pywatemsedem.io.modeloutput.make_routing_vct`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduTarg&quot;</span><span class="p">]</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
        <span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduTarg&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gdf_routing</span><span class="p">[</span><span class="s2">&quot;lnduSource&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">gdf_routing</span> <span class="o">=</span> <span class="n">gdf_routing</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">gdf_routing</span></div>



<div class="viewcode-block" id="convert_arr_from_kg_to_ton">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.convert_arr_from_kg_to_ton">[docs]</a>
<span class="k">def</span> <span class="nf">convert_arr_from_kg_to_ton</span><span class="p">(</span><span class="n">rst_in</span><span class="p">,</span> <span class="n">rst_out</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set values of all pixels of a raster divided by 1000 (kg -&gt; ton)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_in: str or pathlib.Path</span>
<span class="sd">        File path of input raster to set no data values</span>
<span class="sd">    rst_out: str or pathlib.Path</span>
<span class="sd">        File path of output raster with no data values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arr_in</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">load_raster</span><span class="p">(</span><span class="n">rst_in</span><span class="p">)</span>
    <span class="n">arr_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">arr_in</span> <span class="o">==</span> <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">],</span> <span class="n">arr_in</span><span class="p">,</span> <span class="n">arr_in</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span>
    <span class="n">profile</span><span class="p">[</span><span class="s2">&quot;compress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;DEFLATE&quot;</span>
    <span class="n">write_arr_as_rst</span><span class="p">(</span><span class="n">arr_out</span><span class="p">,</span> <span class="n">rst_out</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span></div>



<div class="viewcode-block" id="convert_rst_sinks_to_vct">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.convert_rst_sinks_to_vct">[docs]</a>
<span class="k">def</span> <span class="nf">convert_rst_sinks_to_vct</span><span class="p">(</span><span class="n">rst_in</span><span class="p">,</span> <span class="n">vct_out</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">epsg</span><span class="o">=</span><span class="s2">&quot;EPSG:31370&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a sinks raster to a vector file.</span>

<span class="sd">    A sinks raster is defined as a raster holding captured sediment loads</span>
<span class="sd">    (i.e. rst_sewerin, rst_sediexport).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rst_in: str or pathlib.Path</span>
<span class="sd">        Input raster subject to convert to shape</span>
<span class="sd">    kind: str</span>
<span class="sd">        &#39;sewer&#39; or &#39;river&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vct_out: pathlib.Path</span>
<span class="sd">        Filename of the shapefile of the sinks</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;river&quot;</span><span class="p">,</span> <span class="s2">&quot;sewer&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2"> of sink not in known.&quot;</span><span class="p">)</span>

    <span class="n">rst_in</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">rst_in</span><span class="p">)</span>
    <span class="n">basename</span> <span class="o">=</span> <span class="n">rst_in</span><span class="o">.</span><span class="n">stem</span>

    <span class="n">cmd_args</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;saga_cmd&quot;</span><span class="p">,</span> <span class="n">SAGA_FLAGS</span><span class="p">,</span> <span class="s2">&quot;shapes_grid&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">]</span>
    <span class="n">cmd_args</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;-GRIDS&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">rst_in</span><span class="p">)]</span>
    <span class="n">cmd_args</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;-SHAPES&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)]</span>
    <span class="n">execute_saga</span><span class="p">(</span><span class="n">cmd_args</span><span class="p">)</span>

    <span class="n">gdf_out</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span>
    <span class="n">gdf_out</span> <span class="o">=</span> <span class="n">gdf_out</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span><span class="p">,</span> <span class="n">allow_override</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
    <span class="n">gdf_out</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">basename</span><span class="p">[:</span><span class="mi">11</span><span class="p">]:</span> <span class="s2">&quot;sediment&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="n">gdf_out</span><span class="o">.</span><span class="n">sediment</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span>
    <span class="p">)</span>  <span class="c1"># convert from kg to tonnes</span>
    <span class="n">gdf_out</span> <span class="o">=</span> <span class="n">gdf_out</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;sediment&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;cumsum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
    <span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;cumperc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;cumsum&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">gdf_out</span><span class="p">[</span><span class="s2">&quot;sediment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">gdf_out</span> <span class="o">=</span> <span class="n">gdf_out</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">gdf_out</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gdf_out</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">vct_out</span><span class="p">)</span></div>



<div class="viewcode-block" id="compute_statistics_sediout_outside_domain">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.compute_statistics_sediout_outside_domain">[docs]</a>
<span class="k">def</span> <span class="nf">compute_statistics_sediout_outside_domain</span><span class="p">(</span><span class="n">arr_sediout</span><span class="p">,</span> <span class="n">arr_id</span><span class="p">,</span> <span class="n">df_routing</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute amount of sediout routing outside domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr_sediout: numpy.ndarray</span>
<span class="sd">        WaTEM/SEDEM sediout raster.</span>
<span class="sd">    arr_id: numpy.ndarray</span>
<span class="sd">        An unique array id array, sediout outside domain is grouped by these id&#39;s.</span>
<span class="sd">        Should be integers or floats!</span>
<span class="sd">    df_routing: pandas.DataFrame</span>
<span class="sd">        Loaded WaTEM/SEDEM routing dataframe</span>
<span class="sd">    profile: rasterio.profile</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.Series</span>
<span class="sd">        Series holding sediout outside domain per id.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df_id</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_id</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;sid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;tid1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;tid2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;target1col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;target2col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;target1row&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">]</span>
    <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;target2row&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_id</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">]</span>

    <span class="c1"># couple rows and cols</span>
    <span class="n">df_sediout</span> <span class="o">=</span> <span class="n">raster_array_to_pandas_dataframe</span><span class="p">(</span><span class="n">arr_sediout</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">]</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_id</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;sid&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;target1col&quot;</span><span class="p">,</span> <span class="s2">&quot;target1row&quot;</span><span class="p">]</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_id</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;tid1&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;target2col&quot;</span><span class="p">,</span> <span class="s2">&quot;target2row&quot;</span><span class="p">]</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_id</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;tid2&quot;</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="c1"># source id&#39;s that are not equal to target id&#39;s</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="p">[</span>
        <span class="p">(</span><span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;sid&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;tid1&quot;</span><span class="p">])</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;sid&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;tid2&quot;</span><span class="p">])</span>
    <span class="p">]</span>
    <span class="n">df_routing</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_sediout</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;val1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;part1&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;val2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;part2&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df_routing</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
    <span class="c1"># compute stats</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;tid1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;val1&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">})</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">df_routing</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;tid1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="s2">&quot;val2&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">t1</span><span class="p">[</span><span class="s2">&quot;val1&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">t2</span><span class="p">[</span><span class="s2">&quot;val2&quot;</span><span class="p">]</span></div>



<div class="viewcode-block" id="process_filename">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.process_filename">[docs]</a>
<span class="k">def</span> <span class="nf">process_filename</span><span class="p">(</span>
    <span class="n">fmap_results</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">extension</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">arguments_input</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format full filename</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fmap_results: str or pathlib.Path</span>
<span class="sd">        Folder path where pywatemsedem (scenario_x) input and output is saved</span>
<span class="sd">    subfolder: str or pathlib.Path</span>
<span class="sd">        Folder path in which a specific file &#39;filename&#39; (relative path) resides</span>
<span class="sd">    filename:  str or pathlib.Path</span>
<span class="sd">        File path (without full path, without extension, with string</span>
<span class="sd">        formatting %)</span>
<span class="sd">    extension: str or pathlib.Path</span>
<span class="sd">        Extension of the file</span>
<span class="sd">    arguments: str or pathlib.Path</span>
<span class="sd">        Argument for the string formatting of filename</span>
<span class="sd">    arguments_input: dict</span>
<span class="sd">        Holding the {&quot;year&quot;:year, &quot;scenario&quot;: scenario, &quot;catchment_name&quot;:</span>
<span class="sd">        catchment_name}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    full_filename: pathlib.Path</span>
<span class="sd">        Full filename (absolute path, with filled in string formatting)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    String formatting in the code is done with &#39;%&#39; as the filename variable changes of</span>
<span class="sd">    content and is not accesable with f-strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arguments</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">arguments_input</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="n">scenario</span> <span class="o">=</span> <span class="n">arguments_input</span><span class="p">[</span><span class="s2">&quot;scenario&quot;</span><span class="p">]</span>
        <span class="n">catchment_name</span> <span class="o">=</span> <span class="n">arguments_input</span><span class="p">[</span><span class="s2">&quot;catchment_name&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">arguments</span> <span class="o">==</span> <span class="s2">&quot;year, catchment, scenario&quot;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">%</span> <span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">catchment_name</span><span class="p">,</span> <span class="n">scenario</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arguments</span> <span class="o">==</span> <span class="s2">&quot;catchment&quot;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">%</span> <span class="p">(</span><span class="n">catchment_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arguments</span> <span class="o">==</span> <span class="s2">&quot;catchment, scenario&quot;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">%</span> <span class="p">(</span><span class="n">catchment_name</span><span class="p">,</span> <span class="n">scenario</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arguments</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Argument </span><span class="si">{</span><span class="n">arguments</span><span class="si">}</span><span class="s2"> not found in if/else-clause.&quot;</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">subfolder</span> <span class="o">!=</span> <span class="s2">&quot;main&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">subfolder</span> <span class="o">==</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span>
            <span class="n">subfolder</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">arguments_input</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="s2">&quot;year&quot;</span> <span class="ow">in</span> <span class="n">arguments_input</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
            <span class="p">)</span>
        <span class="n">full_filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fmap_results</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">extension</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">full_filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fmap_results</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">extension</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full_filename</span></div>



<div class="viewcode-block" id="read_filestructure">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.read_filestructure">[docs]</a>
<span class="k">def</span> <span class="nf">read_filestructure</span><span class="p">(</span><span class="n">txt_filestructure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read the pywatemsedem filestructure flanders file containing an overview of the files</span>
<span class="sd">    used for pywatemsedem flanders.</span>

<span class="sd">    The filestructure contains information on files written on disk by pywatemsedem. This</span>
<span class="sd">    file is used by the :class:`pywatemsedem.core.postprocess.PostProcess` object and</span>
<span class="sd">    :class:`pywatemsedem.core.merge_scenarios.SpatialMergeScenarios`.</span>

<span class="sd">    The filestructure pywatemsedem file can be used for to regenerate the filenames</span>
<span class="sd">    in a ``scenario_x`` folder without having to have the pywatemsedem objects loaded in</span>
<span class="sd">    memory (i.e. handy for starting a PostProcess instance from any simulation).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    txt_filestructure : str or pathlib.Path, default None</span>
<span class="sd">        File path of table holding all data files/folder path references used in pywatemsedem</span>
<span class="sd">        flanders.</span>
<span class="sd">    sep : str, default &quot;,&quot;</span>
<span class="sd">        Delimiter of the text file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_filestructure_flanders: pandas.DataFrame</span>

<span class="sd">        - *tag_variable* (str): unique tag used in code to identify file.</span>
<span class="sd">        - *prefix_variable* (str): prefix used for unique tag (depending on whether</span>
<span class="sd">          the file is a raster, text file, vector).</span>
<span class="sd">        - *folder* (str): subfolder in which file can be found in scenario.</span>
<span class="sd">        - *filename* (str): filename without specified arguments</span>
<span class="sd">        - *argument* (str): arguments such as year (int), catchment name (str),</span>
<span class="sd">          scenario label (str)</span>
<span class="sd">        - *extension* (str): extension of the file.</span>
<span class="sd">        - *mandatory* (int): indicate whether file is a mandatory file to run</span>
<span class="sd">          WaTEM/SEDEM.</span>
<span class="sd">        - *condition* (str): indicates whether presence of file is related to a</span>
<span class="sd">          WaTEM/SEDEM option.</span>
<span class="sd">        - *default_value* (float): default value (only for rasters)</span>
<span class="sd">        - *generate_nodata* (int): indicate whether a file must be made replacing 0&#39;s</span>
<span class="sd">          to nan.</span>
<span class="sd">        - *postprocess* (int): use generating for postprocessing.</span>
<span class="sd">        - *consider__* (int): state whether the file has to be loaded (0) or has to be</span>
<span class="sd">          generated (1).</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    1. When no text data set file is defined, than the default defined in this</span>
<span class="sd">       package is used.</span>
<span class="sd">    2. Although the filestructure applies to pywatemsedem flanders, it is defined in the</span>
<span class="sd">       pywatemsedem postprocess.py core function, as the postprocess.py script contains many</span>
<span class="sd">       functionalities only coupled to flanders.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    An example of how the filesystem file can be used in the pywatemsedem code is given</span>
<span class="sd">    below. Assume that you have a pywatemsedem process and model run in</span>
<span class="sd">    ``molenbeek/scenario_1``. For example, if you wish to assign the filename of the</span>
<span class="sd">    buffers raster file in the ``modeloutput`` subfolder of ``scenario_1`` to a</span>
<span class="sd">    variable in pywatemsedem, you can use it as (using pathlib.Path module):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        dict_filenames = {}</span>
<span class="sd">        dict_filename[f&quot;{prefix}_{tag_variable}&quot;] = Path(&quot;molenbeek&quot;) / scenario_1 /</span>
<span class="sd">        f&quot;{folder}&quot; / (filename%argument + &quot;.&quot; + extension)</span>

<span class="sd">    This way, automated filename reconstruction can be guided by the use of this table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">txt_filestructure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;data/postprocess_files.csv&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">txt_filestructure</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">df_filestructure_flanders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>

    <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;tag_variable&quot;</span><span class="p">,</span>
        <span class="s2">&quot;prefix_variable&quot;</span><span class="p">,</span>
        <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
        <span class="s2">&quot;filename&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extension&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mandatory&quot;</span><span class="p">,</span>
        <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
        <span class="s2">&quot;default_value&quot;</span><span class="p">,</span>
        <span class="s2">&quot;generate_nodata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;postprocess&quot;</span><span class="p">,</span>
        <span class="s2">&quot;consider__&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cols</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">df_filestructure_flanders</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;DataFrame should contain </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">df_filestructure_flanders</span><span class="p">[</span><span class="s2">&quot;condition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_filestructure_flanders</span><span class="p">[</span>
        <span class="s2">&quot;condition&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">df_filestructure_flanders</span><span class="p">[</span><span class="s2">&quot;argument&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_filestructure_flanders</span><span class="p">[</span>
        <span class="s2">&quot;argument&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">df_filestructure_flanders</span> <span class="o">=</span> <span class="n">df_filestructure_flanders</span><span class="p">[</span>
        <span class="n">df_filestructure_flanders</span><span class="p">[</span><span class="s2">&quot;consider__&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df_filestructure_flanders</span></div>



<div class="viewcode-block" id="get_tuple_datastructure">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.get_tuple_datastructure">[docs]</a>
<span class="k">def</span> <span class="nf">get_tuple_datastructure</span><span class="p">(</span><span class="n">df_datastructure_files</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get one record of filestruture</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_datastructure_files: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.core.postprocess.read_filestructure_flanders`</span>
<span class="sd">    index :</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f: tuple</span>
<span class="sd">        with &quot;folder&quot;, &quot;filename&quot;, &quot;extension&quot;, &quot;argument&quot;, &quot;mandatory&quot;,</span>
<span class="sd">        &quot;condition&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">df_datastructure_files</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="s2">&quot;folder&quot;</span><span class="p">,</span>
                <span class="s2">&quot;filename&quot;</span><span class="p">,</span>
                <span class="s2">&quot;extension&quot;</span><span class="p">,</span>
                <span class="s2">&quot;argument&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mandatory&quot;</span><span class="p">,</span>
                <span class="s2">&quot;condition&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="get_filename">
<a class="viewcode-back" href="../../api/pywatemsedem.html#pywatemsedem.postprocess.get_filename">[docs]</a>
<span class="k">def</span> <span class="nf">get_filename</span><span class="p">(</span><span class="n">df_datastructure_files</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">simulations</span><span class="p">,</span> <span class="n">scenario</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get filename from datastructure with year, simulation and scenario</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_datastructure_files: pandas.DataFrame</span>
<span class="sd">        See :func:`pywatemsedem.core.postprocess.read_filestructure_flanders`</span>
<span class="sd">    index: any series index</span>
<span class="sd">        index of position dataframe</span>
<span class="sd">    subfolder: str</span>
<span class="sd">        subfolder</span>
<span class="sd">    year: int</span>
<span class="sd">        year of the simulation</span>
<span class="sd">    simulations:</span>
<span class="sd">        name of the simulation, usually catchment name</span>
<span class="sd">    scenario: str</span>
<span class="sd">        scenario tag</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filename : pathlib.Path</span>
<span class="sd">        specific filename</span>
<span class="sd">    mandatory : int</span>
<span class="sd">        indicates wheter a file is mandatory or not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">get_tuple_datastructure</span><span class="p">(</span><span class="n">df_datastructure_files</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="n">argument_inputs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="n">year</span><span class="p">,</span>
        <span class="s2">&quot;catchment_name&quot;</span><span class="p">:</span> <span class="n">simulations</span><span class="p">,</span>
        <span class="s2">&quot;scenario&quot;</span><span class="p">:</span> <span class="n">scenario</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="n">process_filename</span><span class="p">(</span>
        <span class="n">subfolder</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;scenario_</span><span class="si">{</span><span class="n">scenario</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">argument_inputs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">mandatory</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mandatory</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Fluves.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>